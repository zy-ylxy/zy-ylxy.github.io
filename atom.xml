<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JJJ的笔记本</title>
  
  <subtitle>be yourself, be better</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-01-30T02:42:09.300Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>土狗1990</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git使用教程</title>
    <link href="http://example.com/post/de286b5f.html"/>
    <id>http://example.com/post/de286b5f.html</id>
    <published>2023-01-28T09:34:29.000Z</published>
    <updated>2023-01-30T02:42:09.300Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/gitlogo.png"></p><hr/><h1 id="git-教程"><a href="#git-教程" class="headerlink" title="git 教程"></a>git 教程</h1><p>[TOC]</p><h1 id="1-版本管理工具概念"><a href="#1-版本管理工具概念" class="headerlink" title="1.版本管理工具概念"></a>1.版本管理工具概念</h1><p>我在大学毕业写论文的时候的时候碰到过如下的现象</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;&lt;毕业论文第一版.doc&gt;&gt;</span><br><span class="line">&lt;&lt;毕业论文第二版.doc&gt;&gt;</span><br><span class="line">&lt;&lt;毕业论文第三版.doc&gt;&gt;</span><br><span class="line">&lt;&lt;毕业论文最终版.doc&gt;&gt;</span><br><span class="line">&lt;&lt;毕业论文最终版2.doc&gt;&gt;</span><br></pre></td></tr></table></figure><p>类似的问题我曾经也碰到过很多,例如:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">领导让写文档,写好了,领导让修改,改好了,领导觉得第一版不错,改回来吧,此时内心一脸懵,第一版长啥样没存档啊</span><br></pre></td></tr></table></figure><p>实际上,代码开发中也需要这样的软件来管理我们的代码. 例如我们经常会碰到如下的现象:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">改之前好好的,改完就报错了,也没怎么修改啊</span><br></pre></td></tr></table></figure><p>在这种情况下如果不能查看修改之前的代码,查找问题是非常困难的.</p><p>如果有一个软件能记录我们对文档的所有修改,所有版本,那么上面的问题讲迎刃而解.而这类软件我们一般叫做版本控制工具</p><p>版本管理工具一般具有如下特性:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) 能够记录历史版本,回退历史版本</span><br><span class="line">2) 团队开发,方便代码合并</span><br></pre></td></tr></table></figure><h1 id="2-版本管理工具介绍"><a href="#2-版本管理工具介绍" class="headerlink" title="2. 版本管理工具介绍"></a>2. 版本管理工具介绍</h1><p>现在比较流行的版本管理工具是git ,但是实际上git 是近几年才发展起来的,可能有一些老的项目,还在用一些老的软件,比如svn</p><h2 id="2-1版本管理发展简史-维基百科"><a href="#2-1版本管理发展简史-维基百科" class="headerlink" title="2.1版本管理发展简史(维基百科)"></a>2.1版本管理发展简史(维基百科)</h2><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1571983065236.png" alt="1571983065236"> </p><h3 id="2-1-1-SVN-SubVersion"><a href="#2-1-1-SVN-SubVersion" class="headerlink" title="2.1.1 SVN(SubVersion)"></a>2.1.1 SVN(SubVersion)</h3><p>工作流程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SVN是集中式版本控制系统，版本库是集中放在中央服务器的.</span><br><span class="line">工作流程如下:</span><br><span class="line">1.从中央服务器远程仓库下载代码</span><br><span class="line">2.修改后将代码提交到中央服务器远程仓库</span><br></pre></td></tr></table></figure><p>优缺点:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优点: 简单,易操作</span><br><span class="line">缺点:所有代码必须放在中央服务器  </span><br><span class="line">    1.服务器一旦宕机无法提交代码,即容错性较差</span><br><span class="line">      2.离线无法提交代码,无法及时记录我们的提交行为</span><br></pre></td></tr></table></figure><p>svn流程图</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/svn.jpg"></p><h3 id="2-1-2-Git"><a href="#2-1-2-Git" class="headerlink" title="2.1.2 Git"></a>2.1.2 Git</h3><p>工作流程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git是分布式版本控制系统（Distributed Version Control System，简称 DVCS），分为两种类型的仓库：</span><br><span class="line">本地仓库和远程仓库</span><br><span class="line">工作流程如下</span><br><span class="line">    1．从远程仓库中克隆或拉取代码到本地仓库(clone/pull)</span><br><span class="line">    2．从本地进行代码修改</span><br><span class="line">    3．在提交前先将代码提交到暂存区</span><br><span class="line">    4．提交到本地仓库。本地仓库中保存修改的各个历史版本</span><br><span class="line">    5．修改完成后，需要和团队成员共享代码时，将代码push到远程仓库</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/git.png"></p><p>总结:git和svn的区别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. svn 是集中式版本控制工具,git 是分布式版本控制工具</span><br><span class="line">2. svn 不支持离线提交,git 支持离线提交代码</span><br></pre></td></tr></table></figure><h1 id="3-Git-发展简史"><a href="#3-Git-发展简史" class="headerlink" title="3. Git 发展简史"></a>3. Git 发展简史</h1><p> 林纳斯·本纳第克特·托瓦兹（Linus Benedict Torvalds, 1969年~ ） </p><p><img src="./assets/1571987252740.png" alt="1571987252740"></p><p>很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。</p><p>Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？</p><p>事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过<strong>手工方式合并代码！</strong></p><p>你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？那个年代不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，<strong>而且必须联网才能使用</strong>。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是<strong>付费</strong>的，和Linux的开源精神不符。</p><p>不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。而授权的前提是:Linux 社区的人不能开发具有相同功能的竞争产品! </p><p>另一方面,BitKeeper不是开源的. 显然与Linux 的开源精神不相符,所以linux 社区的很多人抱怨,不愿意使用.</p><p>典型的就是  Andrew Tridgell  (Samba 开发服务的创造者) 非常不满.偷偷违反了和 BitKeeper 的协议,反编译 BitKeeper 的源代码,开发了个爬虫,然后爬取信息被人发现了. BitKeeper 公司的领导非常不满意,然后开始发布消息说,(下个版本)不再为Linux 提供免费的服务. </p><p>Linus  本人就出面协调(几周或者几个月),但是不管用, 没办法. 估计谈判的过程感觉到了憋屈–”吃人嘴短,拿人手软”</p><p>Linus  本人 花了10天的时间Git 出来了,一个月之内，Linux系统的源码已经由Git管理了！</p><p> <img src="./assets/1571988966446.png" alt="Linus 采访记录"></p><p>Git 出来以后毕竟是一个人做的,开始并不好用(刚开始只能用勉强可以用来形容), 还是很多人抱怨,发展了很多年都没有干过其他软件.</p><p>直到 2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub,从此git 迎来了飞速发展,当下git 已经成为了最流行的版本控制工具</p><h1 id="4-Git-的安装"><a href="#4-Git-的安装" class="headerlink" title="4. Git 的安装"></a>4. Git 的安装</h1><h2 id="4-1-git-的下载"><a href="#4-1-git-的下载" class="headerlink" title="4.1 git 的下载"></a>4.1 git 的下载</h2><p>下载地址： <a href="https://git-scm.com/download">https://git-scm.com/download</a></p><p><img src="./assets/1571990833074.png" alt="1571990833074"></p><p>附件</p><p><img src="./assets/1571991253594.png" alt="1571991253594"></p><hr/><h2 id="4-2-安装"><a href="#4-2-安装" class="headerlink" title="4.2 安装"></a>4.2 安装</h2><ol><li><p>按照附件的 顺序直接下一步傻瓜式安装即可</p></li><li><p>其中安装的过程中需要填写一个邮箱和用户名(任意即可)</p></li></ol><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572001054551.png" alt="1572001054551"></p><ol start="3"><li><p> $\color{red}{注意: 安装完毕请重启资源管理器,或者重启电脑!!!}$ </p></li><li><p> 更改语言</p></li></ol><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1571992521110.png" alt="1571992521110"></p><h1 id="5-Git-工作流程"><a href="#5-Git-工作流程" class="headerlink" title="5. Git 工作流程"></a>5. Git 工作流程</h1><h2 id="5-1-Git-初始化"><a href="#5-1-Git-初始化" class="headerlink" title="5.1 Git 初始化"></a>5.1 Git 初始化</h2><p>我们先初始化一个本地仓</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) 新建测试文件夹</span><br><span class="line">2) 进入文件夹,然后右键创建版本库</span><br></pre></td></tr></table></figure><p><img src="assets/1571993852280.png" alt="1571993852280"></p><p>此时 我们看到 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) 文件夹上多了一个绿色图标(如果没有请看本章节 5.3小节说明)</span><br><span class="line">2) 文件夹内部生成了一个.git 隐藏文件夹(需要设置隐藏文件夹可见)</span><br></pre></td></tr></table></figure><h2 id="5-2-git-流程"><a href="#5-2-git-流程" class="headerlink" title="5.2  git 流程"></a>5.2  git 流程</h2><h3 id="5-2-1-流程图"><a href="#5-2-1-流程图" class="headerlink" title="5.2.1 流程图"></a>5.2.1 流程图</h3><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/git%E6%B5%81%E7%A8%8B.png"></p><h3 id="5-2-2概念即详解"><a href="#5-2-2概念即详解" class="headerlink" title="5.2.2概念即详解"></a>5.2.2概念即详解</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本地仓库：是在开发人员自己电脑上的Git仓库,存放我们的代码(.git 隐藏文件夹就是我们的本地仓库)</span><br><span class="line">远程仓库：是在远程服务器上的Git仓库,存放代码(可以是github.com或者gitee.com 上的仓库,或者自己该公司的服务器)</span><br><span class="line">工作区: 我们自己写代码(文档)的地方</span><br><span class="line">暂存区: 在 本地仓库中的一个特殊的文件(index) 叫做暂存区,临时存储我们即将要提交的文件</span><br><span class="line">------------</span><br><span class="line">Clone：克隆，就是将远程仓库复制到本地仓库</span><br><span class="line">Push：推送，就是将本地仓库代码上传到远程仓库</span><br><span class="line">Pull：拉取，就是将远程仓库代码下载到本地仓库,并将代码 克隆到本地工作区</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/git%E6%B5%81%E7%A8%8B_%E8%AF%A6%E8%A7%A3.png"></p><h1 id="6-Git-的基本使用01-TortoiseGit-操作本地仓库"><a href="#6-Git-的基本使用01-TortoiseGit-操作本地仓库" class="headerlink" title="6.Git 的基本使用01-TortoiseGit 操作本地仓库"></a>6.Git 的基本使用01-TortoiseGit 操作本地仓库</h1><h2 id="6-1-初始化仓库"><a href="#6-1-初始化仓库" class="headerlink" title="6.1  初始化仓库"></a>6.1  初始化仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法一: </span><br><span class="line">新建一个文件夹,进入文件夹内部操作</span><br><span class="line">1)右键--&gt; 在这里创建Git 版本库 </span><br></pre></td></tr></table></figure><p><img src="assets/1572161580344.png" alt="1572161580344"></p><p>  注意: 不要直接在桌面上操作,否则桌面就是一个仓库</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法二:</span><br><span class="line">2) 右键--&gt;Git GUI here</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572162906623.png" alt="1572162906623"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法三: 命令行模式</span><br><span class="line">2) git init </span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572163015102.png" alt="1572163015102"></p><p>创建完毕仓库,我们发现,此时我们创建的文件夹下有一个.git 文件已经生成了</p><p>并且仓库文件夹上多了一个 绿色图标</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572164583708.png" alt="1572164583708"></p><h2 id="6-2-添加文件"><a href="#6-2-添加文件" class="headerlink" title="6.2 添加文件"></a>6.2 添加文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1)在仓库中新建一个文件</span><br><span class="line">2)选中新建的文件--&gt;右键--&gt; TortoiseGit--&gt; 添加</span><br><span class="line">3)此时我们看到文件夹上多了一个 &quot;加号&quot;</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572164475555.png" alt="1572164475555"></p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572165109016.png" alt="1572165109016"></p><h2 id="6-3-提交文件至本地仓库"><a href="#6-3-提交文件至本地仓库" class="headerlink" title="6.3 提交文件至本地仓库"></a>6.3 提交文件至本地仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1)选中文件</span><br><span class="line">2) 右键--git提交</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572165471421.png" alt="1572165471421"></p><h2 id="6-4-修改文件-与再次提交文件"><a href="#6-4-修改文件-与再次提交文件" class="headerlink" title="6.4 修改文件,与再次提交文件"></a>6.4 修改文件,与再次提交文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">当我们修改文件以后,文件上多了一个红色感叹号,表示我们上次提交后该文件被修改过</span><br><span class="line">提交后文件图标又变成绿色</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572165676716.png" alt="1572165676716"></p><h2 id="6-5-文件状态讲解"><a href="#6-5-文件状态讲解" class="headerlink" title="6.5 文件状态讲解"></a>6.5 文件状态讲解</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Git工作目录下的文件存在两种状态：</span><br><span class="line">1 untracked 未跟踪（未被纳入版本控制） :  比如新建的文件(此时文件夹上没有图标或者有一个&quot;问号&quot;)</span><br><span class="line">2 tracked 已跟踪（被纳入版本控制）     </span><br><span class="line">    2.1 Staged 已暂存状态            : 添加 但未提交状态(此时文件夹上有一个&quot;加号&quot;)</span><br><span class="line">2.2 Unmodified 未修改状态        : 已提交(此时文件夹上有一个&quot;对号&quot;)</span><br><span class="line">2.3 Modified 已修改状态          : 修改了,但是还没有提交 (此时文件夹上有一个&quot;红色感叹号&quot;)</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1569293793902.png"></p><p>这些文件的状态会随着我们执行Git的命令发生变化</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1566627767390.png"></p><h2 id="6-6-修改文件-不提交和上一个版本比较差异-diff"><a href="#6-6-修改文件-不提交和上一个版本比较差异-diff" class="headerlink" title="6.6 修改文件,不提交和上一个版本比较差异(diff)"></a>6.6 修改文件,不提交和上一个版本比较差异(diff)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改文件,此时不要提交</span><br><span class="line">选中文件--&gt;右键--&gt; TortoiseGit--&gt; 比较差异</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572167540734.png" alt="1572167540734"></p><h2 id="6-7-查看提交历史记录"><a href="#6-7-查看提交历史记录" class="headerlink" title="6.7 查看提交历史记录"></a>6.7 查看提交历史记录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">选中文件</span><br><span class="line">右键--&gt; TortoiseGit--&gt; 显示日志</span><br><span class="line">此时我们可以看到所有的历史提交记录</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572167842481.png" alt="1572167842481"></p><p>##6.8 回退至历史版本</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">右键--&gt; TortoiseGit--&gt; 显示日志</span><br><span class="line">选中某个版本--&gt; 进行如下操作</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572171034508.png" alt="1572171034508"></p><h2 id="6-9-文件删除"><a href="#6-9-文件删除" class="headerlink" title="6.9 文件删除"></a>6.9 文件删除</h2><p>###6.9.1本地删除与恢复</p>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) 直接选中文件删除的话,其实只是删除了本地工作区的文件,并没有删除 仓库中的文件</span><br><span class="line">   此时时可以回退的, 比如我们进行如下操作</span><br><span class="line">   1)文件删除</span><br><span class="line">   2)右键--&gt; TortoiseGit--&gt; 还原</span><br><span class="line">   此时我们发现文件又被恢复了</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572169387835.png" alt="1572169387835"></p><h3 id="6-9-2从版本库删除"><a href="#6-9-2从版本库删除" class="headerlink" title="6.9.2从版本库删除"></a>6.9.2从版本库删除</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2) 我们如果真的想要将某个文件从服务器删除,需要进行如下操作</span><br><span class="line">   1) 删除文件,和上面的操作一样</span><br><span class="line">   2) 提交,此时服务文件已经删除了(历史版本还在,还是可以恢复)</span><br></pre></td></tr></table></figure><h3 id="6-9-3从版本库删除-但是不删除本地"><a href="#6-9-3从版本库删除-但是不删除本地" class="headerlink" title="6.9.3从版本库删除,但是不删除本地"></a>6.9.3从版本库删除,但是不删除本地</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们可以如下操作,只删除服务器上的文件,但是本地文件并不删除</span><br><span class="line">备注: 删除之后需要提交,才会真正的从服务器删除</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572171572963.png" alt="1572171572963"></p><h2 id="6-10-忽略提交"><a href="#6-10-忽略提交" class="headerlink" title="6.10 忽略提交"></a>6.10 忽略提交</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有时候我们一些文件是不需要提交的比如说idea/eclipse 开发的代码自动生成的配置文件</span><br><span class="line">如何配置不提交呢</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572172137494.png" alt="1572172137494"></p><p>此时我们的根目录下会生成一个.gitignore 文件</p><p>忽略文件如何阅读,常见格式</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有以.a 结尾的文件讲被忽略(递归)</span></span><br><span class="line"><span class="string">*.a</span></span><br><span class="line"><span class="comment"># 不管其他规则怎样,强制不忽略  lib.a</span></span><br><span class="line"><span class="type">!lib.a</span></span><br><span class="line"><span class="comment"># 只忽略 文件 TODO (注意这里是文件)</span></span><br><span class="line"><span class="string">/TODO</span></span><br><span class="line"><span class="comment"># 忽略 build文件夹下所有内容(递归) 这里是文件夹</span></span><br><span class="line"><span class="string">build/</span></span><br><span class="line"><span class="comment"># 忽略 doc 目录下以 *.txt 结尾的文件 (不递归)</span></span><br><span class="line"><span class="string">doc/*.txt</span></span><br><span class="line"><span class="comment"># 忽略 doc 目录下以 *.pdf 结尾的文件 (递归)</span></span><br><span class="line"><span class="string">doc/**/*.pdf</span></span><br></pre></td></tr></table></figure><p>当然理解了上述规则,我们也可以手动编辑该文件,而不用通过窗口化操作(如果不嫌麻烦)</p><h1 id="7-Git-的基本使用02-TortoiseGit-操作本地仓库-分支"><a href="#7-Git-的基本使用02-TortoiseGit-操作本地仓库-分支" class="headerlink" title="7. Git 的基本使用02-TortoiseGit 操作本地仓库(分支)"></a>7. Git 的基本使用02-TortoiseGit 操作本地仓库(分支)</h1><h2 id="7-1-分支的概念"><a href="#7-1-分支的概念" class="headerlink" title="7.1 分支的概念"></a>7.1 分支的概念</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，避免影响开发主线。多线程开发,可以同时开启多个任务的开发,多个任务之间互不影响.</span><br></pre></td></tr></table></figure><h2 id="7-2-为何要使用分支"><a href="#7-2-为何要使用分支" class="headerlink" title="7.2 为何要使用分支"></a>7.2 为何要使用分支</h2><p>先看单线程开发</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572173978185.png" alt="1572173978185"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">思考如下现象</span><br><span class="line">    10.1 日 业务部门提出需求 : 明年 元旦3天做2个促销活动</span><br><span class="line">1) 12.31 号上线活动1, </span><br><span class="line">2) 1.4 号上线活动2 ,同时 要求撤销 活动1</span><br><span class="line">    你所在 部门领导 为了保证能顺利完成,要求 11.15 号完成 上述连个功能的开发工作</span><br><span class="line">此时作为开发人员:我要面临两个文件, 活动1 的代码,即要存在(12.31 要用)又要不存在(1.4 号要求删除) ,我们怎么做?</span><br><span class="line">显然比较棘手,如果使用分支(可以理解为将代码复制一份)将很好解决</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572174740013.png" alt="1572174740013"></p><h2 id="7-3-创建分支"><a href="#7-3-创建分支" class="headerlink" title="7.3 创建分支"></a>7.3 创建分支</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">到现在为止,我们一直使用的时主分支(master)</span><br><span class="line">在主分支上操作创建分支</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572178189980.png" alt="1572178189980"></p><h2 id="7-4-分支的查看切换"><a href="#7-4-分支的查看切换" class="headerlink" title="7.4 分支的查看切换"></a>7.4 分支的查看切换</h2><h3 id="7-4-1查看分支"><a href="#7-4-1查看分支" class="headerlink" title="7.4.1查看分支"></a>7.4.1查看分支</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看版本分支图,此时我们看到有两个分支</span><br><span class="line">当然,我们可以创建多个分支</span><br><span class="line">可以看到多个分支的图形</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572179420706.png" alt="1572179420706"></p><h3 id="7-4-2切换分支"><a href="#7-4-2切换分支" class="headerlink" title="7.4.2切换分支"></a>7.4.2切换分支</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">右键--&gt; 检出</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572180057481.png" alt="1572180057481"></p><p>##7.5 分支的合并与删除</p><h3 id="7-5-1合并"><a href="#7-5-1合并" class="headerlink" title="7.5.1合并"></a>7.5.1合并</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">我们将代码切换到分支1,然后写属于需求1 的代码并提交</span><br><span class="line">当我们把需求1 开发完毕如何把需求1 的代码合并到主分支呢?</span><br><span class="line">--&gt;1 切换到 主版本</span><br><span class="line">--&gt;2 右键 合并即可将需求1 写的代码合并至主分支</span><br><span class="line">-----此时我们看到代码自动合并到了master分支</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572180623156.png" alt="1572180623156"></p><h3 id="7-5-2删除分支"><a href="#7-5-2删除分支" class="headerlink" title="7.5.2删除分支"></a>7.5.2删除分支</h3><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572183670465.png" alt="1572183670465"></p><p>5,冲突的处理<br>​    5.1)冲突的概念</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">现象演示</span><br><span class="line">开发人员A 开发需求1,开发了一个工具类 MathUtil,里面第一行写了一个方法 add(int [] args)</span><br><span class="line"> 同时开发人员B 开发需求2,开发了一个工具类 MathUtil,里面第一行写了一个方法 add(int a int b)</span><br><span class="line">他们在互相不知道对方需求的情况下同时提交了代码到自己的分支</span><br><span class="line">   思考此时如果我们把需求1 和需求2 同时都合并到主分支上, 主分支的 工具类 MathUtil 的第一行应该使用谁的代码? </span><br><span class="line">   此时主分支是不能智能判断第一行使用谁的代码,合并时会报错,我们叫做冲突.</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572181403239.png" alt="1572181403239"></p><p>​    5.2) 如何处理冲突</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">分析一下冲突的原因:</span><br><span class="line">开发人员之间彼此没有沟通导致的同一个时间节点修改了同一个地方的代码,合并是冲突</span><br><span class="line">思考:</span><br><span class="line">我们能直接把某个开发人员开发的代码删除吗?</span><br><span class="line">显然不能</span><br><span class="line">所以在处理冲突时,第一步应该时找开发另一个需求的人员沟通,之后才是处理冲突</span><br><span class="line">-----</span><br><span class="line">--&gt; 选中冲突的文件(带黄色感叹号的文件都是冲突的文件,如果有多个需要逐一处理)</span><br><span class="line">--&gt; 右键--&gt; 编辑冲突,</span><br><span class="line">--&gt;处理完毕后.标记已解决</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572182565594.png" alt="1572182565594"></p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572182727568.png" alt="1572182727568"></p><h1 id="8-tag-标签"><a href="#8-tag-标签" class="headerlink" title="8.tag  标签"></a>8.tag  标签</h1><h2 id="8-1-标签的概念"><a href="#8-1-标签的概念" class="headerlink" title="8.1 标签的概念"></a>8.1 标签的概念</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果你的项目达到一个重要的阶段，并希望永远记住那个特别的提交快照，你可以给它打上标签(tag)</span><br><span class="line">比如说，我们想为我们的项目发布一个&quot;1.0&quot;版本。 我们给最新一次提交打上（HEAD）&quot;v1.0&quot;的标签。</span><br><span class="line">标签可以理解为项目里程碑的一个标记,一旦打上了这个标记则,表示当前的代码将不允许提交</span><br></pre></td></tr></table></figure><h2 id="8-2-标签的创建-tag"><a href="#8-2-标签的创建-tag" class="headerlink" title="8.2  标签的创建(tag)"></a>8.2  标签的创建(tag)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标签的创建和分支的创建操作几乎一样</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572183849972.png" alt="1572183849972"></p><h2 id="8-3-标签的切换与删除"><a href="#8-3-标签的切换与删除" class="headerlink" title="8.3 标签的切换与删除"></a>8.3 标签的切换与删除</h2><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572184030612.png" alt="1572184030612"></p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572184109746.png" alt="1572184109746"></p><h1 id="9-远程仓库"><a href="#9-远程仓库" class="headerlink" title="9. 远程仓库"></a>9. 远程仓库</h1><p>我们的代码不能总是放在本地,因为总是放在本地,一旦电脑出现故障,数据将丢失,怎么共享呢,这里我们需要一个服务器, 我们可以把代码放到服务器上,然后让别人下载,这样我峨嵋你既可以备份代码,也可以进行团队协作开发</p><h2 id="9-0-局域网仓库"><a href="#9-0-局域网仓库" class="headerlink" title="9.0 局域网仓库"></a>9.0 局域网仓库</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实际上我们可以搭建一个单间的局域网服务器共享我们的代码</span><br></pre></td></tr></table></figure><h3 id="9-0-1本地相对路径-多个文件夹之间共享代码"><a href="#9-0-1本地相对路径-多个文件夹之间共享代码" class="headerlink" title="9.0.1本地相对路径,多个文件夹之间共享代码"></a>9.0.1本地相对路径,多个文件夹之间共享代码</h3><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572535798760.png" alt="1572535798760"></p><h3 id="9-0-2开启局域网共享代码"><a href="#9-0-2开启局域网共享代码" class="headerlink" title="9.0.2开启局域网共享代码"></a>9.0.2开启局域网共享代码</h3><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572535921581.png" alt="1572535921581"></p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572536029899.png" alt="1572536029899"></p><p>局域网这种共享是没有安全控制的,都可以访问,如果想要搭建一个可以控制权限的服务器需要借助第三方软件</p><p>gitblit,可以自行搜索搭建</p><h2 id="9-1-常用远程仓库托管服务"><a href="#9-1-常用远程仓库托管服务" class="headerlink" title="9.1 常用远程仓库托管服务"></a>9.1 常用远程仓库托管服务</h2><p>除了自己搭建服务器,其实我们可以使用一些免费的远程仓库,远程仓库有很多,常见的免费互联网远程仓库托管服务如下:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.github.com</span><br><span class="line">www.gitee.com</span><br><span class="line">www.gitlab.com</span><br><span class="line"></span><br><span class="line">github  是一个基于git实现在线代码托管的仓库，向互联网开放，企业版要收钱。</span><br><span class="line">gitee    即码云，是 oschina 免费给企业用的，不用自己搭建环境。</span><br><span class="line">gitlab   类似 github，一般用于在企业内搭建git私服，要自己搭环境。</span><br><span class="line"></span><br><span class="line">GitHub(gitee)、GitLab 不同点：</span><br><span class="line">1、GitHub如果使用私有仓库是需要付费的，(2019年开始私有仓库也是免费的但是只能3个人协同开发,想要更多需要收费)，GitLab可以在上面搭建私人的免费仓库。</span><br><span class="line">2、GitLab让开发团队对他们的代码仓库拥有更多的控制，相对于GitHub，它有不少的特色：</span><br><span class="line">    (1)允许免费设置仓库权限</span><br><span class="line">    (2)允许用户选择分享一个project的部分代码</span><br><span class="line">    (3)允许用户设置project的获取权限，进一步提升安全性</span><br><span class="line">    (4)可以设置获取到团队整体的改进进度</span><br><span class="line">    (5)通过innersourcing让不在权限范围内的人访问不到该资源</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>鉴于国内用户可能网络不好,这里我们使用gitee(码云) 来讲解我们的课程,其他可自行找资料学习非常类似</p><h2 id="9-2-码云账号注册"><a href="#9-2-码云账号注册" class="headerlink" title="9.2  码云账号注册"></a>9.2  码云账号注册</h2><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572267659865.png" alt="1572267659865"></p><p>填写邮箱发送验证码,然后可以注册账号,主页如下</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572268091948.png" alt="1572268091948"></p><h2 id="9-3-创建远程仓库"><a href="#9-3-创建远程仓库" class="headerlink" title="9.3 创建远程仓库"></a>9.3 创建远程仓库</h2><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572274044100.png" alt="1572274044100"></p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/224637.png"></p><p>各个类型仓库之间的区别</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572274100802.png" alt="1572274100802"></p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572274406371.png" alt="1572274406371"></p><h2 id="9-4-把本地代码推送到远端"><a href="#9-4-把本地代码推送到远端" class="headerlink" title="9.4  把本地代码推送到远端"></a>9.4  把本地代码推送到远端</h2><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572275202869.png" alt="1572275202869"></p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572275492670.png" alt="1572275492670"></p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572275546739.png" alt="1572275546739"></p><p>此时我们刷新仓库发现代码已经存在了</p><p>我们填写的用户信息,会被保存在本地,下次提交无需填写用户名和密码</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572277483698.png" alt="1572277483698"></p><h2 id="9-5-从远程仓库克隆代码"><a href="#9-5-从远程仓库克隆代码" class="headerlink" title="9.5  从远程仓库克隆代码"></a>9.5  从远程仓库克隆代码</h2><p>我们同样可以从库下载代码,</p><p>新建一个文件夹 repo2 ,进入然后进行如下操作</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572275958701.png" alt="1572275958701"></p><p>此时我们发现我们的代码已经被下载下来了</p><h2 id="9-6-代码的修改与提交-查看历史"><a href="#9-6-代码的修改与提交-查看历史" class="headerlink" title="9.6  代码的修改与提交,查看历史"></a>9.6  代码的修改与提交,查看历史</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1)此时我们修改代码就不能仅仅是提交到本地了,提交完毕应该推送到远端服务器</span><br><span class="line">2)此时如果别人从远端仓库下载最新的代码其实是可以看到我们的代码修改记录的</span><br><span class="line">   git --&gt;显示日志</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572277139243.png" alt="1572277139243"></p><h2 id="9-7-ssh-连接概述"><a href="#9-7-ssh-连接概述" class="headerlink" title="9.7 ssh 连接概述"></a>9.7 ssh 连接概述</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">实际上git 不仅仅支持用户名密码方式的配置,可以有另外一种相对更加安全的配置即ssh 方式配置</span><br></pre></td></tr></table></figure><p> ssh 方式的底层原理</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh连接地城是RAS加密算法,又称非对称加密,是一种现在公认的最安全的加密方式</span><br><span class="line">数学基础好的同学可以研究一下</span><br><span class="line">https://www.cnblogs.com/cjm123/p/8243424.html</span><br><span class="line"></span><br><span class="line">公钥私钥加密可以看作古代 的&quot;虎符&quot; , 我们本地电脑有一份,远程服务器有一份, 只要 &quot;虎符&quot; 核对通过 表示身份无误,可以执行提交等操作,无需输入用户名密码</span><br></pre></td></tr></table></figure><h2 id="9-8-ssh-密钥的生成"><a href="#9-8-ssh-密钥的生成" class="headerlink" title="9.8 ssh 密钥的生成"></a>9.8 ssh 密钥的生成</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#生成公钥私钥</span><br><span class="line"> ssh-keygen -t rsa</span><br><span class="line"> 一直回车即可</span><br><span class="line"> 会默认用户目录 .ssh 目录生成一个默认的id_rsa文件 和id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572520139221.png" alt="1572520139221"></p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572520293700.png" alt="1572520293700"></p><h2 id="9-9-ssh-密钥配置"><a href="#9-9-ssh-密钥配置" class="headerlink" title="9.9 ssh 密钥配置"></a>9.9 ssh 密钥配置</h2><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572520396806.png" alt="1572520396806"></p><h2 id="9-10-ssh-方式克隆-提交代码"><a href="#9-10-ssh-方式克隆-提交代码" class="headerlink" title="9.10 ssh 方式克隆/提交代码:"></a>9.10 ssh 方式克隆/提交代码:</h2><p>  配置完成之后我们克隆我们之前的项目</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572522118610.png" alt="1572522118610"></p><p>修改后直接提交推送即可成功,,git 会自动去.ssh 目录找我们的私钥进行匹配</p><h2 id="9-11-远程仓库的其他操作"><a href="#9-11-远程仓库的其他操作" class="headerlink" title="9.11. 远程仓库的其他操作"></a>9.11. 远程仓库的其他操作</h2><p>概念</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572522822946.png" alt="1572522822946"></p><p>当我们从 gitee 上查看别人的项目的时候我们可能会看到上图中的按钮</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">指数:</span><br><span class="line">是gitee 网站根据当前项目的各项指标计算出来的一个值</span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572523045267.png" alt="1572523045267"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Star:</span><br><span class="line">点赞, 注意这里的并不像朋友圈那样容易获得点赞,圈内人还是很克制的</span><br><span class="line">Watch:</span><br><span class="line">   如果你watch 了某个开源项目,那么这个项目后续所有的改动你将收到通知</span><br><span class="line">Fork :</span><br><span class="line">将别人的代码克隆到你自己的仓库</span><br><span class="line">作用一: 如果担心某个优秀的项目别人突然有一天不开源了,你可以fork到自己的仓库</span><br><span class="line">    作用二: 修改别人的代码</span><br><span class="line">  以linux 为例,你其实不是linux 社区的开发人员,但是你 又想为linux 开发做贡献(维护代码)</span><br><span class="line">   你并没有权限,怎们办?</span><br><span class="line">   你可以先把linux 开源的代码 fork 到你自己的仓库,此时你就可以操作自己的仓库进行修改代码了</span><br><span class="line">   如何让别人合并你修改好的代码呢? </span><br><span class="line">    我们注意项目的上方有一个 &quot; Pull Request&quot; 这个按钮的意思是 &quot;请求求别人合并你修改的代码&quot;</span><br><span class="line">    当我们发起一个 Pull Request 时 , 项目的拥有者将收到 Pull Request请求,然后将根据你提交代码的质量决定是否合并</span><br></pre></td></tr></table></figure><p>项目操作</p><p>1)我们可以删除修改我们自己仓库的基本信息</p><ol start="2"><li>我们可以邀请其他人成为项目的开发人员或者管理人员</li></ol><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572523819666.png" alt="1572523819666"></p><p>我们可以删除修改我们自己仓库的基本信息</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572523928774.png" alt="1572523928774"></p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572523968992.png" alt="1572523968992"></p><h2 id="9-12-利用-gitee-搭建个人主页"><a href="#9-12-利用-gitee-搭建个人主页" class="headerlink" title="9.12 利用 gitee 搭建个人主页"></a>9.12 利用 gitee 搭建个人主页</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1)将静态资源上传至仓库</span><br><span class="line">2) 选择服务 pages 即可部署</span><br><span class="line">注意 1)必须有个index.html 文件</span><br><span class="line">注意 2) 只能搭建静态网站,动态网站请租赁服务器搭建提供服务</span><br><span class="line">注意 3) gitee 要求必须绑定手机号</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572525575923.png" alt="1572525575923"></p><p>点击开启后gitee 会自动生成一个域名</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572526097257.png" alt="1572526097257"></p><p>直接访问即可</p><p>此时我们已经在git 上部署了一个静态的网站</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1572526136074.png" alt="1572526136074"></p><h1 id="10-命令行–-git基本操作"><a href="#10-命令行–-git基本操作" class="headerlink" title="10.命令行– git基本操作"></a>10.命令行– git基本操作</h1><h2 id="10-1-介绍"><a href="#10-1-介绍" class="headerlink" title="10.1  介绍"></a>10.1  介绍</h2><p>​    上述我们的操作 使用的 是客户端TortoiseGit 操作的git ,实际上底层依旧是使用的命令行帮我们执行, 在早期 git 并没有窗口化工具,开发人员只能使用命令行模式</p><p>  实际上,如果你掌握并熟练使用了命令行模式操作git 的话,你会发现某些操作命令行比窗口化操作要简单</p><p>所有你在工作中会发现高深的技术人员可能会喜欢命令行模式提交git</p><p>##10.2 环境配置</p><p>当安装Git后首先要做的事情是设置用户名称和email地址。这是非常重要的，因为每次Git提交都会使用该用户信息</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">设置用户信息</span> </span><br><span class="line">   git config --global user.name “itcast”</span><br><span class="line">   git config --global user.email “itcast@itcast.cn”</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看配置信息</span></span><br><span class="line">   git config --list</span><br><span class="line">   git config user.name</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">通过上面的命令设置的信息会保存在~/.gitconfig文件中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>##10.3  初始化本地仓库 init</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化仓库带工作区</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">初始化仓库不带工作区</span></span><br><span class="line">git init --bare  </span><br></pre></td></tr></table></figure><p>##10.4 克隆 clone</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从远程仓库克隆</span></span><br><span class="line">git clone 远程Git仓库地址 </span><br><span class="line">例如: git clone https://gitee.com/itcast/gittest.git</span><br></pre></td></tr></table></figure><p>##10.5  查看状态 status</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看状态</span></span><br><span class="line">git status </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看状态 使输出信息更加简洁</span></span><br><span class="line">git status –s </span><br></pre></td></tr></table></figure><p>##10.6 add </p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将未跟踪的文件加入暂存区</span></span><br><span class="line">git add  &lt;文件名&gt;  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将暂存区的文件取消暂存 (取消 add )</span></span><br><span class="line">git reset  &lt;文件名&gt;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>##10.7 commit</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git commit 将暂存区的文件修改提交到本地仓库</span></span><br><span class="line">git commit -m &quot;日志信息&quot;  &lt;文件名&gt;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>##10.8 删除 rm</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从本地工作区 删除文件</span></span><br><span class="line">git rm &lt;文件名&gt;  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果本工作区库误删, 想要回退</span></span><br><span class="line">git checkout head &lt;文件名&gt;  </span><br></pre></td></tr></table></figure><h1 id="11-命令行–git-远程仓库操作"><a href="#11-命令行–git-远程仓库操作" class="headerlink" title="11. 命令行–git 远程仓库操作"></a>11. 命令行–git 远程仓库操作</h1><h2 id="11-1-查看远程"><a href="#11-1-查看远程" class="headerlink" title="11.1    查看远程"></a>11.1    查看远程</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看远程  列出指定的每一个远程服务器的简写</span></span><br><span class="line">git remote </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看远程 , 列出 简称和地址</span></span><br><span class="line">git remote  -v  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看远程仓库详细地址</span></span><br><span class="line">git remote show  &lt;仓库简称&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="11-2-添加-移除远测仓库"><a href="#11-2-添加-移除远测仓库" class="headerlink" title="11.2 添加/移除远测仓库"></a>11.2 添加/移除远测仓库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加远程仓库</span></span><br><span class="line">git remote add &lt;shortname&gt; &lt;url&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">移除远程仓库和本地仓库的关系(只是从本地移除远程仓库的关联关系，并不会真正影响到远程仓库)</span></span><br><span class="line">git remote rm &lt;shortname&gt; </span><br></pre></td></tr></table></figure><h2 id="11-3-从远程仓库获取代码"><a href="#11-3-从远程仓库获取代码" class="headerlink" title="11.3 从远程仓库获取代码"></a>11.3 从远程仓库获取代码</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从远程仓库克隆</span></span><br><span class="line">git clone &lt;url&gt; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从远程仓库拉取 (拉取到.git 目录,不会合并到工作区,工作区发生变化)</span></span><br><span class="line">git fetch  &lt;shortname&gt;  &lt;分支名称&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">手动合并  把某个版本的某个分支合并到当前工作区</span></span><br><span class="line">git merge &lt;shortname&gt;/&lt;分支名称&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从远程仓库拉取 (拉取到.git 目录,合并到工作区,工作区不发生变化) = fetch+merge</span></span><br><span class="line">git pull  &lt;shortname&gt;  &lt;分支名称&gt;</span><br><span class="line">git pull  &lt;shortname&gt;  &lt;分支名称&gt;  --allow-unrelated-histories  #  强制拉取合并</span><br></pre></td></tr></table></figure><p>注意：如果当前本地仓库不是从远程仓库克隆，而是本地创建的仓库，并且仓库中存在文件，此时再从远程仓库拉取文件的时候会报错（fatal: refusing to merge unrelated histories ），解决此问题可以在git pull命令后加入参数–allow-unrelated-histories (如上 命令)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将本地仓库推送至远程仓库的某个分支</span></span><br><span class="line">git push [remote-name] [branch-name]</span><br></pre></td></tr></table></figure><h1 id="12-命令行–-分支"><a href="#12-命令行–-分支" class="headerlink" title="12.  命令行– 分支"></a>12.  命令行– 分支</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认 分支名称为 master</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有本地分支</span></span><br><span class="line">git branch</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有本地分支和远程分支</span></span><br><span class="line">git branch -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建分支</span></span><br><span class="line">git branch &lt;分支名&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换分支</span> </span><br><span class="line">git checkout &lt;分支名&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除分支(如果分支已经修改过,则不允许删除)</span></span><br><span class="line">git branch -d  &lt;分支名&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制删除分支</span></span><br><span class="line">git branch -D  &lt;分支名&gt;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交分支至远程仓库</span></span><br><span class="line">git push &lt;仓库简称&gt; &lt;分支名称&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并分支 将其他分支合并至当前工作区</span></span><br><span class="line">git merge &lt;分支名称&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程仓库分支</span></span><br><span class="line">git push origin –d branchName</span><br></pre></td></tr></table></figure><h1 id="13-命令行-–tag"><a href="#13-命令行-–tag" class="headerlink" title="13 . 命令行 –tag"></a>13 . 命令行 –tag</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有tag</span></span><br><span class="line">git tag</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看tag详细信息</span> </span><br><span class="line">git show [tagName]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个tag</span></span><br><span class="line">git tag [tagName]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">提交指定tag</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push [仓库简称] [tagName]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建一个分支，指向某个tag</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b [branch] [tag]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除本地tag</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d [tag]</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除远程tag (注意 空格)</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin :refs/tags/[tag]</span></span><br></pre></td></tr></table></figure><h1 id="14-案例"><a href="#14-案例" class="headerlink" title="14. 案例"></a>14. 案例</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">企业中我们是如何开发的</span><br><span class="line">1) 入职第一天,管理人员分配/git账号密码 </span><br><span class="line">2) 开发人员下载代码即文档/ 根据文档将环境搭建成功</span><br><span class="line">3) 团队一般会给你讲讲项目相关的支持</span><br><span class="line">----</span><br><span class="line">4) 你接到第一个需求(或者某个功能,一般要经过沟通,分析,设计...等过程)</span><br><span class="line">5) 创建feature分支(一般一个需求对应一个feature,命名格式上标注该需求的id)</span><br><span class="line">6) 开发需求,本地测试,提交代码到当前需求对应的feature分支,</span><br><span class="line">一般来讲为了避免将测试代码提交,需要提交前,检查如下步骤</span><br><span class="line">6.1) 是否多提交了某个文件,比如测试文件</span><br><span class="line">6.2) 是否漏提交文件</span><br><span class="line">6.3) 打开每一个应该提交的文件,判断是否多提交了一行代码,是否少提交了一行代码,是否删除了本应该存在的代码 </span><br><span class="line">检查完毕提交代码</span><br><span class="line">7) 合并分支至test分支-- 测试人员会在test分支中测试</span><br><span class="line">8) 测试人员测试bug ,开发者在feature分支上继续修改,提交</span><br><span class="line">9) 测试人员测试通过 ,test分支会被测试人员合并到develop开发分支,再次测试</span><br><span class="line">10)develop分支最终会被合并到master主分支</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/gitlogo.png&quot;&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;h1 id=&quot;git-教程&quot;&gt;&lt;a href=&quot;#git-教程&quot; class=&quot;headerlink&quot;</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="git" scheme="http://example.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>自定义组件</title>
    <link href="http://example.com/post/48fa52e7.html"/>
    <id>http://example.com/post/48fa52e7.html</id>
    <published>2022-11-23T03:40:28.000Z</published>
    <updated>2022-11-29T11:11:09.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h4><ol><li>创建components-&gt;’组件名称’ 文件夹</li><li>在新建文件夹上右键新建components</li></ol><h4 id="引入组件"><a href="#引入组件" class="headerlink" title="引入组件"></a>引入组件</h4><p>组件引入方式有“<font color='red'><strong>局部引用</strong></font>”和“<font color='red'><strong>全局引用</strong></font>”</p><h5 id="局部引用"><a href="#局部引用" class="headerlink" title="局部引用"></a>局部引用</h5><p>在页面的.json配置文件中引用组件的方式</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>    </span><br><span class="line">  <span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;myButton&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/components/myButton/myButton&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="全局引用"><a href="#全局引用" class="headerlink" title="全局引用"></a>全局引用</h5><p>在app.json配置文件中引用组件的方式</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span>    </span><br><span class="line">  <span class="attr">&quot;usingComponents&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;myButton&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/components/myButton/myButton&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h5 id="组件和页面的区别"><a href="#组件和页面的区别" class="headerlink" title="组件和页面的区别"></a>组件和页面的区别</h5><p>从表面来看，组件和页面都是由<code>.js</code>  <code> .json</code>   <code>.wxml</code> <code>.wxss</code>四个文件,组件和页面<code>.js</code>  <code> .json</code>文件有不同</p><ul><li>组件的<code> .json</code>文件中需要声明<code>&quot;component&quot;:true</code>属性</li><li>组件的<code>.js</code>文件中调用的是Component()函数</li><li>组建的事件处理函数需要定义到methods节点中</li></ul><h3 id="组件样式"><a href="#组件样式" class="headerlink" title="组件样式"></a>组件样式</h3><h4 id="组件样式隔离"><a href="#组件样式隔离" class="headerlink" title="组件样式隔离"></a>组件样式隔离</h4><p>就是默认情况下,组件与组件之间,组件与页面之间样式互不影响</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221123121535906.png" alt="image-20221123121535906"></p><p><strong>注意</strong></p><ul><li><u>app.wxss中的全局样式对组件无效</u></li><li>只有<font color='red'><strong>class选择器</strong></font>会有样式隔离效果,<font color='red'><strong>id</strong></font>选择器,<font color='red'><strong>属性</strong></font>选择器,<font color='red'><strong>标签</strong></font>选择器不受样式隔离影响</li></ul><h4 id="修改组件的样式隔离选项"><a href="#修改组件的样式隔离选项" class="headerlink" title="修改组件的样式隔离选项"></a>修改组件的样式隔离选项</h4><p>有时候希望外界能够控制组件内部的样式,可以通过styleIsolation修改样式隔离选项</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改.js</span></span><br><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 组件的属性列表</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">styleIsolation</span>: <span class="string">&#x27;shared&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">//或者修改.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;styleIsolation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shared&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221123122139174.png" alt="image-20221123122139174"></p><h3 id="组件数据、方法和属性"><a href="#组件数据、方法和属性" class="headerlink" title="组件数据、方法和属性"></a>组件数据、方法和属性</h3><h4 id="data数据"><a href="#data数据" class="headerlink" title="data数据"></a>data数据</h4><p>在小程序组件中,<font color='red'><strong>用于组件模板渲染</strong></font>的<font color='red'><strong>私有数据</strong></font>,需要定义到<font color='red'><strong>data点</strong></font>中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="methods节点"><a href="#methods节点" class="headerlink" title="methods节点"></a>methods节点</h4><p>在小程序组件中,<font color='red'><strong>事件处理函数</strong></font>和<font color='red'><strong>自定义方法</strong></font>需要定义到<font color='red'><strong>methods节点</strong></font>中</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 组件的方法列表</span></span><br><span class="line">    <span class="title function_">addCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 事件处理函数</span></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">count</span> + <span class="number">1</span> &#125;)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">_showCount</span>() <span class="comment">//通过this直接调用自定义方法</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">_showCount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 自定义方法建议以_开头</span></span><br><span class="line">      wx.<span class="title function_">showToast</span>(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;count值为：&#x27;</span> + <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">count</span>,</span><br><span class="line">        <span class="attr">icon</span>: <span class="string">&#x27;none&#x27;</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="properties属性"><a href="#properties属性" class="headerlink" title="properties属性"></a>properties属性</h4><p>在小程序组件中,properties是组件的对外属性,<font color='red'><strong>用来接收外界传递到组件中的数据</strong></font></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">properties</span>: &#123;</span><br><span class="line">    <span class="comment">// 完整定义，类型+默认值</span></span><br><span class="line">    <span class="attr">max</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 简化定义，指定类型</span></span><br><span class="line">    <span class="attr">max</span>:<span class="title class_">Number</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">myButton</span> <span class="attr">max</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">myButton</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="data和properties的区别"><a href="#data和properties的区别" class="headerlink" title="data和properties的区别"></a>data和properties的区别</h4><p>在小程序组件中,properties属性和data数据的用法相同,他们都是可读可写的,只不过:</p><ul><li>data更倾向于<u>存储组件的私有数据</u></li><li>properties更倾向于<u>存储外界传递到组件中的数据</u></li></ul><h4 id="使用setData修改properties的值"><a href="#使用setData修改properties的值" class="headerlink" title="使用setData修改properties的值"></a>使用setData修改properties的值</h4><p>由于<font color='red'><strong>data数据</strong></font>和<font color='red'><strong>properties属性</strong></font>在本质上没有任何区别,因此properties属性的值也可以用于页面渲染,或使用setData为properties中的属性重新赋值</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;<span class="attr">max</span>: <span class="variable language_">this</span>.<span class="property">properties</span>.<span class="property">max</span> + <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="数据监听器"><a href="#数据监听器" class="headerlink" title="数据监听器"></a>数据监听器</h3><h4 id="什么是数据监听器"><a href="#什么是数据监听器" class="headerlink" title="什么是数据监听器"></a>什么是数据监听器</h4><p>用于监听和响应<u>任何属性</u>和<u>数据字段</u>的变化，从而执行特定的操作。类似watch侦听器</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">observers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;字段A, 字段B&#x27;</span>: <span class="keyword">function</span> (<span class="params">字段A的新值, 字段B的新值</span>) &#123;</span><br><span class="line"><span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="监听对象中所有属性的变化"><a href="#监听对象中所有属性的变化" class="headerlink" title="监听对象中所有属性的变化"></a>监听对象中所有属性的变化</h5><p>如果某个对象中需要被监听的属性太多，为了方便，可以使用<font color='red'><strong>通配符<code>**</code>来监听</strong></font>对象中所有属性的变化</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123; </span><br><span class="line">  <span class="attr">observers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;rgb.**&#x27;</span>: <span class="keyword">function</span> (<span class="params">r, g, b</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">fullColor</span>: <span class="string">`<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;g&#125;</span>,<span class="subst">$&#123;b&#125;</span>`</span>,</span><br><span class="line">        <span class="attr">textColor</span>: <span class="string">`<span class="subst">$&#123;<span class="number">255</span> - r&#125;</span>,<span class="subst">$&#123;<span class="number">255</span> - g&#125;</span>,<span class="subst">$&#123;<span class="number">255</span> -b&#125;</span>`</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><h3 id="纯数据字段"><a href="#纯数据字段" class="headerlink" title="纯数据字段"></a>纯数据字段</h3><h4 id="什么是纯数据字段"><a href="#什么是纯数据字段" class="headerlink" title="什么是纯数据字段"></a>什么是纯数据字段</h4><p>概念：<font color='red'><strong>纯数据字段</strong></font>指的是那些<font color='red'><strong>不用于界面渲染的data字段</strong></font>，有助于提升页面更新的性能。</p><p>应用场景：例如有些情况下，某些data中的字段既不会展示在界面上，也不会传递给其他组件，仅仅在当前组件内部使用。带有这种特性的data字段适合被设置为纯数据字段</p><h4 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h4><p>在Component构造器的options节点中，指定pureDataPattern为一个正则表达式，字段名符合这个正则表达式的字段将成为纯数据字段。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="comment">// 指定所有_ 开头的数据字段为纯数据字段</span></span><br><span class="line">        <span class="attr">pureDataPattern</span>: <span class="regexp">/^_/</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">a</span>: <span class="literal">true</span>, <span class="comment">// 普通数据字段</span></span><br><span class="line">        <span class="attr">_b</span>: <span class="literal">true</span>, <span class="comment">// 纯数据字段</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><h4 id="组件有哪些生命周期"><a href="#组件有哪些生命周期" class="headerlink" title="组件有哪些生命周期"></a>组件有哪些生命周期</h4><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221128101005238.png" alt="image-20221128101005238"></p><h4 id="主要的生命周期函数"><a href="#主要的生命周期函数" class="headerlink" title="主要的生命周期函数"></a>主要的生命周期函数</h4><ol><li><p>组件刚被创建，created触发</p><ul><li>此时不能调用data</li><li>通常在这个生命周期函数中，只应该用于给组件的this添加一些自定义的属性字段</li></ul></li><li><p>组件完全初试化完毕，进入页面节点树，attached触发</p><ul><li>this.data已被初始化完毕</li><li>可以做绝大多数初始化工作</li></ul></li><li><p>组件离开页面节点树后，detached触发</p><ul><li>适合做一些清理性质的工作</li></ul></li></ol><h4 id="lifetimes-节点"><a href="#lifetimes-节点" class="headerlink" title="lifetimes 节点"></a>lifetimes 节点</h4><p>在lifetimes节点中配置组件的证明周期</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">lifetimes</span>: &#123;</span><br><span class="line">    <span class="title function_">created</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;created&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">attached</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;attached&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">detached</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="组件所在页面的生命周期函数"><a href="#组件所在页面的生命周期函数" class="headerlink" title="组件所在页面的生命周期函数"></a>组件所在页面的生命周期函数</h3><h4 id="什么是组件所在页面的生命周期"><a href="#什么是组件所在页面的生命周期" class="headerlink" title="什么是组件所在页面的生命周期"></a>什么是组件所在页面的生命周期</h4><p>当<u>自定义组件的行为<font color='red'><strong>依赖于页面状态的变化</strong></font></u>时，需要用到组件所在页面的生命周期。</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221128105625003.png" alt="image-20221128105625003"></p><h4 id="pageLifetime节点"><a href="#pageLifetime节点" class="headerlink" title="pageLifetime节点"></a>pageLifetime节点</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">component</span>(&#123;</span><br><span class="line">  <span class="attr">pageLifetimes</span>: &#123;</span><br><span class="line">    <span class="title function_">show</span>(<span class="params"></span>) &#123; &#125;,</span><br><span class="line">    <span class="title function_">hide</span>(<span class="params"></span>) &#123; &#125;,</span><br><span class="line">    <span class="title function_">resize</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><h4 id="什么是插槽"><a href="#什么是插槽" class="headerlink" title="什么是插槽"></a>什么是插槽</h4><p>在自定义组件的wxml结构中，可以提供一个<code>&lt;slot&gt;</code>节点，用于承载组件使用者提供的wxml结构</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221128112435364.png" alt="image-20221128112435364"></p><h4 id="单个插槽"><a href="#单个插槽" class="headerlink" title="单个插槽"></a>单个插槽</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//在组件中声明<span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">//test自定义组件</span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>这是我的组件<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">//index页面使用组件</span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span>view我的slot内容<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="多个插槽"><a href="#多个插槽" class="headerlink" title="多个插槽"></a>多个插槽</h4><p>需要在自定义组件.js中配置options节点中的multipleSlots属性为true</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">options</span>: &#123;</span><br><span class="line">    <span class="attr">pureDataPattern</span>: <span class="regexp">/^_/</span>,</span><br><span class="line">    <span class="attr">multipleSlots</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在自定义组件中<code>&lt;slot&gt;</code>用name属性区分不同slot插槽，在页面使用组件中用slot属性定义插槽结构</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//在组件中声明<span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">//test自定义组件</span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>这是我的组件<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;one&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;two&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">slot</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">//index页面使用组件</span><br><span class="line"><span class="tag">&lt;<span class="name">test</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">slot</span>=<span class="string">&quot;one&quot;</span>&gt;</span>view我的slot内容<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">slot</span>=<span class="string">&quot;two&quot;</span>&gt;</span>view我的slot内容<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组件之间的通信"><a href="#组件之间的通信" class="headerlink" title="组件之间的通信"></a>组件之间的通信</h3><h4 id="父子组件三种通信方式"><a href="#父子组件三种通信方式" class="headerlink" title="父子组件三种通信方式"></a>父子组件三种通信方式</h4><p>属性绑定、事件绑定</p><h4 id="属性绑定"><a href="#属性绑定" class="headerlink" title="属性绑定"></a>属性绑定</h4><p>用于父组件向子组件的指定属性设置数据，仅能设置<font color='red'><strong>JSON兼容</strong></font>的数据</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="comment">//在properties中声明d</span></span><br><span class="line">  <span class="attr">properties</span>: &#123;</span><br><span class="line">    <span class="comment">// 完整定义，类型+默认值</span></span><br><span class="line">    <span class="attr">count</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">Number</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 简化定义，指定类型</span></span><br><span class="line">    <span class="comment">// max:Number</span></span><br><span class="line">  &#125;,</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//子组件test</span><br><span class="line"><span class="tag">&lt;<span class="name">text</span>&gt;</span></span><br><span class="line">  &#123;&#123;count&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">//页面调用子组件</span><br><span class="line"><span class="tag">&lt;<span class="name">test</span> <span class="attr">count</span>=<span class="string">&quot;&#123;&#123;nums&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">nums</span>: <span class="number">10</span></span><br><span class="line">  &#125;,</span><br><span class="line">)&#125;</span><br></pre></td></tr></table></figure><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><p>实现子向父传值，可以<font color='red'><strong>传递任何类型的数据</strong></font></p><ol><li>在父组件的<code>.js</code>定义一个函数，通过自定义事件的形式传递给子组件</li><li>在子组件中<code>.js</code>，通过调用<code>this.triggerEvent(‘自定义事件名称’，&#123;/*参数对象*/&#125;)</code>，将数据传给父组件</li><li>在父组件的<code>.js</code>用e.detail获取子组件传递过来的数据</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">showCount</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">        <span class="attr">count</span>: e.<span class="property">detail</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">test</span> <span class="attr">bindshow</span>=<span class="string">&quot;showCount&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个函数调用this.triggerEvent或者之间在生命周期函数调用</span></span><br><span class="line"><span class="title function_">tranCount</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">triggerEvent</span>(<span class="string">&quot;show&quot;</span>,<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">count</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取组件实例"><a href="#获取组件实例" class="headerlink" title="获取组件实例"></a>获取组件实例</h4><p>在父组件里调用this.selectComponent(“id或class选择器”)，获取子组件的实例对象，从而直接访问子组件的任意数据和方法，调用时候需要传入一个选择器</p><h3 id="behaviors"><a href="#behaviors" class="headerlink" title="behaviors"></a>behaviors</h3><p>用于<font color='red'><strong>实现组件间代码共享</strong></font>的特性，类似，mixins</p><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><p>每个behavior可以包含一组<font color='red'><strong>属性</strong></font>、<font color='red'><strong>数据</strong></font>、<font color='red'><strong>生命周期函数</strong></font>和<font color='red'><strong>方法</strong></font>。组件引用它时，它的属性、数据和方法会被合并到组件中。每个组件可以引用多个behavior，behavior也可以引用其他behavior</p><h4 id="创建behavior"><a href="#创建behavior" class="headerlink" title="创建behavior"></a>创建behavior</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用Behavior（）方法，创建实例对象</span></span><br><span class="line"><span class="comment">// 并使用module.exports奖behavior实例对象共享出去</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="title class_">Behavior</span>(&#123;</span><br><span class="line">    <span class="attr">properties</span>:&#123;&#125;,</span><br><span class="line">    <span class="attr">data</span>:&#123; <span class="attr">username</span>:<span class="string">&#x27;zs&#x27;</span> &#125;,</span><br><span class="line">    <span class="attr">methods</span>:&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="导入并使用behavior"><a href="#导入并使用behavior" class="headerlink" title="导入并使用behavior"></a>导入并使用behavior</h4><p>使用require()方法导入需要的behavior，挂载后即可访问behavior中的数据或方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myBehavior = <span class="built_in">require</span>(<span class="string">&quot;../../behaviors/my-behavior&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Component</span>(&#123;</span><br><span class="line">    <span class="attr">behaviors</span>: [myBehavior],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;自定义组件&quot;&gt;&lt;a href=&quot;#自定义组件&quot; class=&quot;headerlink&quot; title=&quot;自定义组件&quot;&gt;&lt;/a&gt;自定义组件&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="小程序" scheme="http://example.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>wxs语法</title>
    <link href="http://example.com/post/857d9cf3.html"/>
    <id>http://example.com/post/857d9cf3.html</id>
    <published>2022-11-22T05:48:54.000Z</published>
    <updated>2022-11-22T07:45:26.135Z</updated>
    
    <content type="html"><![CDATA[<h4 id="WXS概述"><a href="#WXS概述" class="headerlink" title="WXS概述"></a>WXS概述</h4><h5 id="什么是wxs"><a href="#什么是wxs" class="headerlink" title="什么是wxs"></a>什么是wxs</h5><p><font color='red'><strong>WXS</strong></font>（WeiXin Script）是小程序独有的一套<u>脚本语言</u>，结合WXML，可以构建出页面的结构</p><h5 id="wxs的应用场景"><a href="#wxs的应用场景" class="headerlink" title="wxs的应用场景"></a>wxs的应用场景</h5><p>wxml中无法调用在页面的<code>.js</code>中定义的函数，但是，wxml中可以调用wxs中定义的函数。因此，小程序中wxs的典型应用场景就是<font color='red'><strong>“过滤器”</strong></font></p><h5 id="wxs和javaScript的关系"><a href="#wxs和javaScript的关系" class="headerlink" title="wxs和javaScript的关系"></a>wxs和javaScript的关系</h5><p>虽然wxs的语法类似于JavaScript，但是wxs和JavaScript是完全不同的两种语言：</p><ol><li><p>wxs有<font color='orange'><strong>自己的数据类型</strong></font></p><ul><li><u>number</u>数值类型、<u>string</u>字符串类型、<u>boolean</u>布尔类型、<u>object</u>对象类型</li><li><u>function</u>函数类型、<u>array</u>数组类型、<u>date</u>日期类型、<u>regexp</u>正则</li></ul></li><li><p>wxs<font color='orange'><strong>不支持类似于ES6</strong></font>以及以上的语法形式</p><ul><li> <font color='red'><strong>不支持</strong></font>：let、const、解构赋值、展开运算符、箭头函数、对象属性简写、etc…</li><li> <font color='red'><strong>支持</strong></font>：var定义变量、普通function函数等类似于ES5的语法</li></ul></li><li><p>wxs遵循<font color='orange'><strong>CommonJS规范</strong></font></p><ul><li><font color='cornflowerblue'><strong>module</strong></font>对象</li><li><font color='cornflowerblue'><strong>require()</strong></font>函数</li><li><font color='cornflowerblue'><strong>module.exports</strong></font>对象</li></ul></li></ol><h4 id="WXS基本语法"><a href="#WXS基本语法" class="headerlink" title="WXS基本语法"></a>WXS基本语法</h4><h5 id="内嵌wxs脚本"><a href="#内嵌wxs脚本" class="headerlink" title="内嵌wxs脚本"></a>内嵌wxs脚本</h5><p>wxs代码可以编写在wxml文件中的<code>&lt;wxs&gt;</code>标签内,就像javascript代码可以编写在html文件中的<code>&lt;script&gt;</code>标签内一样</p><p>wxml文件中的每个<code>&lt;wxs&gt;&lt;/wxs&gt;</code>标签,必须提供<font color='red'><strong>module属性</strong></font>,用来指定<font color='red'><strong>当前wxs的模块名称</strong></font>,方便wxml中访问模块中的成员:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123;m1.toUpper(username)&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">wxs</span> <span class="attr">module</span>=<span class="string">&quot;m1&quot;</span>&gt;</span></span><br><span class="line">  module.exports.toUpper = function (str) &#123;</span><br><span class="line">    return str.toUpperCase()</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">wxs</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="定义外联的wxs脚本"><a href="#定义外联的wxs脚本" class="headerlink" title="定义外联的wxs脚本"></a>定义外联的wxs脚本</h5><p>wxs代码还可以编写在以<code>.wxs</code>为后缀名的文件内,就像js代码可以编写在以<code>.js</code>为后缀名的文件一样</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">toLower</span>(<span class="params">str</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">toLowerCase</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">toLower</span>: toLower</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用外联的wxs脚本"><a href="#使用外联的wxs脚本" class="headerlink" title="使用外联的wxs脚本"></a>使用外联的wxs脚本</h5><p>在wxml中引入外联的wxs脚本时,必须为<code>&lt;wxs&gt;</code>标签添加module和src属性,其中:</p><ul><li><strong>module</strong>用来指定模块的名称</li><li><strong>src</strong>用来指定要引入的脚本路径,且<font color='red'><strong>必须是相对路径</strong></font><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123;m2.toLower(sex)&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">wxs</span> <span class="attr">module</span>=<span class="string">&quot;m2&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../../utils/tools.wxs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">wxs</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="WXS特点"><a href="#WXS特点" class="headerlink" title="WXS特点"></a>WXS特点</h4><ol><li><p>与JS不同</p></li><li><p>不能作为组件的事件回调</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;m2.toLower&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>隔离性：wxs的运行环境和其他js代码是隔离的</p><ul><li>wxs不能调用js中定义的函数</li><li>wxs不能调用小程序提供的API</li></ul></li><li><p>性能好</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;WXS概述&quot;&gt;&lt;a href=&quot;#WXS概述&quot; class=&quot;headerlink&quot; title=&quot;WXS概述&quot;&gt;&lt;/a&gt;WXS概述&lt;/h4&gt;&lt;h5 id=&quot;什么是wxs&quot;&gt;&lt;a href=&quot;#什么是wxs&quot; class=&quot;headerlink&quot; title=&quot;什</summary>
      
    
    
    
    
    <category term="小程序" scheme="http://example.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序导航</title>
    <link href="http://example.com/post/e63f2ef5.html"/>
    <id>http://example.com/post/e63f2ef5.html</id>
    <published>2022-11-21T07:13:09.000Z</published>
    <updated>2022-11-22T07:43:50.613Z</updated>
    
    <content type="html"><![CDATA[<h4 id="小程序中实现页面导航的两种方式"><a href="#小程序中实现页面导航的两种方式" class="headerlink" title="小程序中实现页面导航的两种方式"></a>小程序中实现页面导航的两种方式</h4><ol><li>声明式导航<ul><li>在页面上声明一个<code>&lt;navigator&gt;</code> 导航组件</li><li>通过点击<code>&lt;navigator&gt;</code>组件实现页面跳转</li></ul></li><li>编程式导航<ul><li>调用小程序的导航API，实现页面的跳转</li></ul></li></ol><h5 id="声明式导航"><a href="#声明式导航" class="headerlink" title="声明式导航"></a>声明式导航</h5><ol><li><p>导航到tabBar页面</p><blockquote><p><font color='red'><strong>tabBar页面</strong></font>指的是被配置为tabBar的页面。</p><p>在使用<code>&lt;navigator&gt;</code>组件跳转到指定的tabBar页面时，需要指定url属性和open-type属性，其中：</p><ul><li><p>url表示要跳转的<font color='orange'><strong>页面的地址</strong></font>，必须以<code>/</code>开头</p></li><li><p>open-type 表示<font color='orange'><strong>跳转的方式</strong></font>，必须为switchTab</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">&quot;/pages/index/index&quot;</span> <span class="attr">open-type</span>=<span class="string">&quot;switchTab&quot;</span>&gt;</span>导航到消息页面<span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>导航到非tabBar页面</p><blockquote><p><font color='red'><strong>非tabBar页面</strong></font>指的是没有被配置为tabBar的页面。</p><p>在使用<code>&lt;navigator&gt;</code>组件跳转到普通的非tabBar页面时，需要指定url属性和open-type属性，其中：</p><ul><li><p>url表示要跳转的<font color='orange'><strong>页面的地址</strong></font>，必须以<code>/</code>开头</p></li><li><p>open-type 表示<font color='orange'><strong>跳转的方式</strong></font>，navigate</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">&quot;/pages/info/index&quot;</span> <span class="attr">open-type</span>=<span class="string">&quot;navigate&quot;</span>&gt;</span>导航到info页面<span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>后退导航</p><blockquote><p>如果要后退到上一页或多级页面，则需要指定delta属性和open-type属性，其中：</p><ul><li><p>open-type的值必须为navigateBack，表示要进行后退导航</p></li><li><p>delta的值必须是数字，表示要后退的层级</p></li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">open-type</span>=<span class="string">&quot;navigateBack&quot;</span> <span class="attr">daelta</span>=<span class="string">&#x27;1&#x27;</span>&gt;</span>后退<span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li></ol><h5 id="编程式导航"><a href="#编程式导航" class="headerlink" title="编程式导航"></a>编程式导航</h5><ol><li><p>导航到tabBar页面</p><blockquote><p>调用wx.switchTab()方法</p><p>![image-20221121160505782](C:\Users\hello world\AppData\Roaming\Typora\typora-user-images\image-20221121160505782.png)</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;gotoIndex&quot;</span>&gt;</span>导航到消息页面<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">gotoIndex() &#123;</span><br><span class="line"> wx.switchTab(&#123;</span><br><span class="line">url: &#x27;/pages/index/index&#x27;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>导航到非tabBar页面</p><blockquote><p>调用wx.navigateTo()方法</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221121160243702.png" alt="image-20221121160243702"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;gotoInfo&quot;</span>&gt;</span>导航到info页面<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">gotoIndex() &#123;</span><br><span class="line"> wx.navigateTo(&#123;</span><br><span class="line">url: &#x27;/pages/info/index&#x27;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>后退导航</p><blockquote><p>调用wx.navigateBack()方法，可以返回上一页面或多级也页面</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221121160357950.png" alt="image-20221121160357950"></p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">bindtap</span>=<span class="string">&quot;gotoBack&quot;</span>&gt;</span>后退<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">gotoIndex() &#123;</span><br><span class="line"> wx.navigateBac()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><h4 id="导航传参"><a href="#导航传参" class="headerlink" title="导航传参"></a>导航传参</h4><h5 id="声明式导航传参"><a href="#声明式导航传参" class="headerlink" title="声明式导航传参"></a>声明式导航传参</h5><p>navigator组件的url属性用来指定将要跳转到的页面的路劲。同时，路径后面还可以<font color='red'><strong>携带参数</strong></font>：</p><ul><li>参数与路径之间使用<font color='red'><strong>？</strong></font>分隔</li><li>参数见键与参数值用<font color='red'><strong>=</strong></font>相连</li><li>不同参数用<font color='red'><strong>&amp;</strong></font>分隔</li></ul><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigator</span> <span class="attr">url</span>=<span class="string">&quot;/pages/info/index?name=zs&amp;age=18&quot;</span> <span class="attr">open-type</span>=<span class="string">&quot;navigate&quot;</span>&gt;</span>导航到info页面<span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="编程式导航传参"><a href="#编程式导航传参" class="headerlink" title="编程式导航传参"></a>编程式导航传参</h5><p>调用wx.navigateTo(Object object) 方法跳转页面，也是在url的路径后面携带参数</p> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button bindtap=<span class="string">&quot;gotoInfo&quot;</span>&gt;导航到info页面&lt;/button&gt; </span><br><span class="line"><span class="title function_">gotoInfo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    wx.<span class="title function_">navigateTo</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">&#x27;/pages/info/index?name=zs&amp;age=18&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="在onLoad中接收导航参数"><a href="#在onLoad中接收导航参数" class="headerlink" title="在onLoad中接收导航参数"></a>在onLoad中接收导航参数</h5><p>通过声明或者编程式所携带的参数，可以直接在onLoad事件中直接获取到</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="comment">// 页面传参</span></span><br><span class="line">  <span class="attr">query</span>: &#123;&#125;</span><br><span class="line">&#125;, </span><br><span class="line"><span class="title function_">onLoad</span>(<span class="params">options</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">    <span class="attr">query</span>: options</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;小程序中实现页面导航的两种方式&quot;&gt;&lt;a href=&quot;#小程序中实现页面导航的两种方式&quot; class=&quot;headerlink&quot; title=&quot;小程序中实现页面导航的两种方式&quot;&gt;&lt;/a&gt;小程序中实现页面导航的两种方式&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;声明式导航&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="小程序" scheme="http://example.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    <category term="导航" scheme="http://example.com/tags/%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>network</title>
    <link href="http://example.com/post/608487bc.html"/>
    <id>http://example.com/post/608487bc.html</id>
    <published>2022-11-18T09:21:28.000Z</published>
    <updated>2022-11-21T07:14:36.435Z</updated>
    
    <content type="html"><![CDATA[<h4 id="小程序中网络数据请求的限制"><a href="#小程序中网络数据请求的限制" class="headerlink" title="小程序中网络数据请求的限制"></a>小程序中网络数据请求的限制</h4><p>出于安全性方面的考虑，小程序官方对数据接口的请求做出了两个限制：</p><ol><li>只能请求<font color=red><strong>HTTPS</strong></font>类型的接口</li><li>必须将<font color=red><strong>接口的域名</strong></font>添加到信任列表中</li></ol><h4 id="配置request合法域名"><a href="#配置request合法域名" class="headerlink" title="配置request合法域名"></a>配置request合法域名</h4><p>需求描述：假设在自己的微信小程序中，希望请求xxx域名下的接口</p><p>配置步骤：登录微信小程序管理后台-》开发-》开发设置-》服务器域名-》修改request合法域名</p><h4 id="发起GET请求"><a href="#发起GET请求" class="headerlink" title="发起GET请求"></a>发起GET请求</h4><p>调用微信小程序提供的<code>wx.request()</code>方法，可以发起GET数据请求，示例代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.<span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">22</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="发起post请求"><a href="#发起post请求" class="headerlink" title="发起post请求"></a>发起post请求</h4><p>调用微信小程序提供<code>wx.request()</code>方法，可以发起post数据请求，示例代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">wx.<span class="title function_">request</span>(&#123;</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;xxx&#x27;</span>,</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;zs&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">22</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">success</span>: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)wx.</span><br></pre></td></tr></table></figure><h4 id="跳过request合法域名校验"><a href="#跳过request合法域名校验" class="headerlink" title="跳过request合法域名校验"></a>跳过request合法域名校验</h4><p>如果后端程序员仅仅提供http协议的接口，暂时没有提供https协议的接口。</p><p>此时为了不耽误开发的进度，我们可以在微信开发者工具中，临时开启【开发环境不校验请求域名，TLS版本及HTTPS证书】选项，跳过request合法域名的校验。</p><p>注意：跳过request合法域名校验的选项，仅限在开发与调试阶段使用</p><h4 id="关于跨域和Ajax的说明"><a href="#关于跨域和Ajax的说明" class="headerlink" title="关于跨域和Ajax的说明"></a>关于<font color='red'><strong>跨域</strong></font>和Ajax的说明</h4><p>跨域问题<font color='red'><strong>只存在</strong></font>基于浏览器的Web开发中。由于<font color='orange'><strong>小程序的宿主环境</strong></font>不是浏览器，而是<font color='orange'><strong>微信客户端</strong></font>，所以小程序<u>不存在跨域问题</u>。</p><p>Ajax技术的核心是依赖于浏览器中的XMLHttpRequesst这个对象，由于小程序的宿主环境是微信客户端，所以小程序中不能叫做”发起Ajax请求“，而是叫做”<font color='red'><strong>发起网络数据请求</strong></font>“。</p><h4 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h4><h5 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h5><p><strong>跨域</strong>是指一个域下的文档或脚本试图去请求另一个域下的资源，当一个请求url的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面url不同即为跨域。（就是前端调用的后端接口不属于同一个域[]域名或端口不同]，就会产生跨域问题）</p><h5 id="为什么会有跨域问题"><a href="#为什么会有跨域问题" class="headerlink" title="为什么会有跨域问题"></a>为什么会有跨域问题</h5><p>核心原因在于浏览器的同源策略限制。<strong>同源策略</strong>（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。</p><h6 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h6><blockquote><ul><li>浏览器的同源策略，限制了来自不同源的”document”或脚本，对当前”document”读取或设置某些属性。从一个域上加载的脚本不允许访问另外一个域的文档属性。</li><li>在浏览器中，<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe</code>&gt;、<code>&lt;link&gt;</code>等标签都可以加载跨域资源，而不受同源限制，但浏览器限制了JavaScript的权限使其不能读、写加载的内容。</li><li>另外同源策略只对网页的HTML文档做了限制，对加载的其他静态资源如javascript、css、图片等仍然认为属于同源。</li><li>同源策略又分为以下两种：</li><li>DOM 同源策略：禁止对不同源页面 DOM 进行操作。这里主要场景是 iframe 跨域的情况，不同域名的 iframe 是限制互相访问的。</li><li>XMLHttpRequest 同源策略：禁止使用 XHR 对象向不同源的服务器地址发起 HTTP 请求。</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;小程序中网络数据请求的限制&quot;&gt;&lt;a href=&quot;#小程序中网络数据请求的限制&quot; class=&quot;headerlink&quot; title=&quot;小程序中网络数据请求的限制&quot;&gt;&lt;/a&gt;小程序中网络数据请求的限制&lt;/h4&gt;&lt;p&gt;出于安全性方面的考虑，小程序官方对数据接口的请求做出</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="小程序" scheme="http://example.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    <category term="get" scheme="http://example.com/tags/get/"/>
    
    <category term="post" scheme="http://example.com/tags/post/"/>
    
    <category term="跨域问题" scheme="http://example.com/tags/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    
    <category term="同源策略" scheme="http://example.com/tags/%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>rpx单位</title>
    <link href="http://example.com/post/a26348b1.html"/>
    <id>http://example.com/post/a26348b1.html</id>
    <published>2022-11-18T08:30:16.000Z</published>
    <updated>2022-11-22T07:44:06.597Z</updated>
    
    <content type="html"><![CDATA[<h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><ol><li>能说出什么是rpx尺寸单位</li><li>能熟练使用rpx</li></ol><hr><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ul><li><p>什么是rpx尺寸单位</p></li><li><p>rpx的实现原理</p></li><li><p>rpx与px之间的单位换算</p></li></ul><h5 id="什么是rpx尺寸单位"><a href="#什么是rpx尺寸单位" class="headerlink" title="什么是rpx尺寸单位"></a>什么是rpx尺寸单位</h5><blockquote><p><font color="red"><strong>rpx</strong></font>是微信小程序独有的，用来解决<font color=red><strong>屏适配</strong> </font>的尺寸单位。</p></blockquote><h5 id="rpx的实现原理"><a href="#rpx的实现原理" class="headerlink" title="rpx的实现原理"></a>rpx的实现原理</h5><blockquote><p>rpx把所有设备的屏幕，在<font color=red><strong>宽度上等分为750份</strong></font>（即：当前屏幕的总宽度为750rpx）</p></blockquote><ul><li>在小的设备上，1rpx所代表的宽度较小</li><li>在大的设备上，1rpx所代表的宽度较大</li><li>从而达到不同设备，会自动把rpx的样式单位换算成对应的像素单位来渲染，从而实现屏幕自动适配大小</li></ul><h5 id="rpx与px之间的单位换算"><a href="#rpx与px之间的单位换算" class="headerlink" title="rpx与px之间的单位换算"></a>rpx与px之间的单位换算</h5><p>在iPhone6上，屏幕宽度为375px，共有750个物理像素，等分为750rpx。则<br>$$<br>750rpx = 375px = 750物理像素<br>$$</p><p>$$<br>1rpx = 0.5px = 1物理像素<br>$$</p><p>![image-20221118165810027](C:\Users\hello world\AppData\Roaming\Typora\typora-user-images\image-20221118165810027.png)</p><p>官方建议：开发微信小程序时，设计师可以用iPhone6作为视觉稿的标准，因为在iPhone6中，1px等于2rpx</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;能说出什么是rpx尺寸单位&lt;/li&gt;
&lt;li&gt;能熟练使用rpx&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4 id=&quot;</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
    <category term="小程序" scheme="http://example.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>flex布局</title>
    <link href="http://example.com/post/28d88e6.html"/>
    <id>http://example.com/post/28d88e6.html</id>
    <published>2022-11-18T06:18:11.000Z</published>
    <updated>2022-11-21T07:00:50.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ol><li>能说出Flex布局是什么？</li><li>能知道Flex容器与项目的属性有哪些？</li><li>能熟练使用Flex布局。</li></ol><hr><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li>Flex布局是什么</li><li>容器的属性</li><li>项目的属性</li></ul><h4 id="一、Flex布局是什么？"><a href="#一、Flex布局是什么？" class="headerlink" title="一、Flex布局是什么？"></a>一、Flex布局是什么？</h4><blockquote><p>Flex是Flexible Box的缩写，意为”<strong>弹性布局</strong>”，用来为盒状模型提供最大的灵活性。采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。</p></blockquote><p><em>注意，设为Flex布局以后，子元素的float、clear和vertical-align属性将失效。</em></p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221118143405626.png" alt="image-20221118143405626"></p><p>容器默认存在两根轴：<strong>水平的主轴</strong>（main axis）和<strong>垂直的交叉轴</strong>（cross axis）</p><ul><li><p>主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；</p></li><li><p>交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p></li><li><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p></li></ul><h4 id="二、容器的属性"><a href="#二、容器的属性" class="headerlink" title="二、容器的属性"></a>二、容器的属性</h4><blockquote><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul></blockquote><h5 id="1、flex-direction"><a href="#1、flex-direction" class="headerlink" title="1、flex-direction"></a>1、flex-direction</h5><p> 属性决定<font color=#ff0000><strong>主轴的方向</strong></font>（即项目的排列方向）。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>row（默认值）：主轴为水平方向，起点在左端。</li><li>row-reverse：主轴为水平方向，起点在右端。</li></ul><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221118150117987.png" alt="image-20221118150117987" style="zoom: 67%;" /><ul><li>column：主轴为垂直方向，起点在上沿。</li><li>column-reverse：主轴为垂直方向，起点在下沿。</li></ul><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221118150127889.png" alt="image-20221118150127889" style="zoom:67%;" /><h5 id="2、flex-wrap"><a href="#2、flex-wrap" class="headerlink" title="2、flex-wrap"></a>2、flex-wrap</h5><p>属性定义，如果一条轴线排不下，如何<font color=#ff0000><strong>换行。</strong></font></p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221118145850338.png" alt="image-20221118145850338" style="zoom:67%;" /><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>nowrap（默认）：不换行。</li></ul><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221118145941970.png" alt="image-20221118145941970" style="zoom:67%;" /><ul><li>wrap：换行，第一行在上方。</li></ul><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221118145949052.png" alt="image-20221118145949052" style="zoom:67%;" /><ul><li>wrap-reverse：换行，第一行在下方。</li></ul><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221118145955689.png" alt="image-20221118145955689" style="zoom:67%;" /><h5 id="3、flex-flow"><a href="#3、flex-flow" class="headerlink" title="3、flex-flow"></a>3、flex-flow</h5><p>属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="4、justify-content"><a href="#4、justify-content" class="headerlink" title="4、justify-content"></a>4、justify-content</h5><p>属性定义了项目<font color=#ff0000><strong>在主轴上的对齐方式</strong></font>。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221118150041127.png" alt="image-20221118150041127" style="zoom:67%;" /><h5 id="5、align-items"><a href="#5、align-items" class="headerlink" title="5、align-items"></a>5、align-items</h5><p>属性定义项目<font color=#ff0000><strong>在交叉轴上如何对齐</strong></font>。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221118150218808.png" alt="image-20221118150218808" style="zoom: 67%;" /><h5 id="6、align-content"><a href="#6、align-content" class="headerlink" title="6、align-content"></a>6、align-content</h5><p>属性定义了<font color=#ff0000><strong>多根轴线的对齐方式</strong></font>。如果项目只有一根轴线，该属性不起作用。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>flex-start：与交叉轴的起点对齐。</p></li><li><p>flex-end：与交叉轴的终点对齐。</p></li><li><p>center：与交叉轴的中点对齐。</p></li><li><p>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</p></li><li><p>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</p></li><li><p>stretch（默认值）：轴线占满整个交叉轴。</p></li></ul><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221118150725636.png" alt="image-20221118150725636" style="zoom:67%;" /><h4 id="三、项目的属性"><a href="#三、项目的属性" class="headerlink" title="三、项目的属性"></a>三、项目的属性</h4><blockquote><p>order、flex-grow、flex-shrink、flex-basis、flex、align-self</p></blockquote><h5 id="1、order"><a href="#1、order" class="headerlink" title="1、order"></a>1、order</h5><p>order属性定义项目的<font color=#ff0000><strong>排列顺序</strong></font>。数值越小，排列越靠前，默认为0。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221118155904713.png" alt="image-20221118155904713" style="zoom:67%;" /><h5 id="2、flex-grow"><a href="#2、flex-grow" class="headerlink" title="2、flex-grow"></a>2、flex-grow</h5><p>flex-grow属性定义项目的<font color=#ff0000><strong>放大比例</strong></font>，默认为0，即如果存在剩余空间，也不放大。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221118160934496.png" alt="image-20221118160934496" style="zoom:67%;" /><p><em>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</em></p><h5 id="3、flex-shrink"><a href="#3、flex-shrink" class="headerlink" title="3、flex-shrink"></a>3、flex-shrink</h5><p>flex-shrink属性定义了项目的<font color=#ff0000><strong>缩小比例</strong></font>，默认为1，即如果空间不足，该项目将缩小。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</em></p><p><em>负值对该属性无效。</em></p><h5 id="4、flex-basis"><a href="#4、flex-basis" class="headerlink" title="4、flex-basis"></a>4、flex-basis</h5><p>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。            </p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</em></p><h5 id="5、flex"><a href="#5、flex" class="headerlink" title="5、flex"></a>5、flex</h5><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="string">&#x27;flex-basis&#x27;</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h5 id="6、align-self"><a href="#6、align-self" class="headerlink" title="6、align-self"></a>6、align-self</h5><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/image-20221118161135675.png" alt="image-20221118161135675" style="zoom:67%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;能说出Flex布局是什么？&lt;/li&gt;
&lt;li&gt;能知道Flex容器与项目的属性有哪些？&lt;/li&gt;
&lt;li&gt;能熟练使</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="flew布局" scheme="http://example.com/tags/flew%E5%B8%83%E5%B1%80/"/>
    
    <category term="CSS" scheme="http://example.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>javaScript高级程序设计-01</title>
    <link href="http://example.com/post/4c20e02f.html"/>
    <id>http://example.com/post/4c20e02f.html</id>
    <published>2022-10-20T01:38:36.000Z</published>
    <updated>2022-11-17T12:21:47.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ol><li>能说出var、let、const三者的区别。</li><li>能说出7种数据类型。</li></ol><hr><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;能说出var、let、const三者的区别。&lt;/li&gt;
&lt;li&gt;能说出7种数据类型。&lt;/li&gt;
&lt;/ol&gt;
&lt;h</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="javaScrpipt" scheme="http://example.com/tags/javaScrpipt/"/>
    
  </entry>
  
  <entry>
    <title>软件测试（三）</title>
    <link href="http://example.com/post/35ba3109.html"/>
    <id>http://example.com/post/35ba3109.html</id>
    <published>2022-10-13T07:39:30.000Z</published>
    <updated>2022-11-17T15:43:12.664Z</updated>
    
    <content type="html"><![CDATA[<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ol><li>能够说出软件缺陷判定标准</li><li>能够说出项目中缺陷的管理流程</li><li>能够使用Excel对于缺陷进行管理</li><li>能使用工具管理缺陷</li></ol><hr><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ol><li>缺陷介绍</li><li>缺陷编写</li><li>缺陷管理工具</li><li>案例</li></ol><h4 id="缺陷介绍"><a href="#缺陷介绍" class="headerlink" title="缺陷介绍"></a>缺陷介绍</h4><ol><li><p>缺陷的定义：软件在使用过程中存在的任何<strong>问题</strong>都叫软件的缺陷，简称Bug </p></li><li><p>缺陷的判刑标准</p><ul><li> 软件未实现需求（规格）说明书中明确要求的功能——<strong>少功能</strong></li><li> 软件出现了需求（规格）说明书中指明不应该出现的错误——<strong>功能错误</strong></li><li> 软件实现的功能超出需求（规格）说明书指明的范围——<strong>多功能</strong></li><li> 软件未实现需求（规格）说明书中虽未明确指明但应该实现的要求——<strong>隐形功能错误</strong></li><li> 软件难以理解，补一使用，运行缓慢，用户体验不好——<strong>不易使用</strong></li></ul></li><li><p>缺陷产生的原因</p><ul><li><strong>需求阶段</strong>：需求描述不易理解，有歧义、错误等</li><li><strong>设计阶段</strong>：设计文档存在错误或者缺陷</li><li><strong>编码缺陷</strong>：代码出现错误</li><li><strong>运行系统</strong>：软硬件系统本身故障导致软件缺陷</li></ul></li><li><p>软件缺陷的生命周期</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1665652650888.png" alt="1665652650888"></p></li><li><p>缺陷的核心内容</p></li></ol><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1665653948916.png" alt="1665653948916"></p><ol start="6"><li>缺陷提交要素</li></ol><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1665653971701.png" alt="1665653971701"></p><ol start="7"><li>缺陷分类<ol><li>功能错误</li><li>UI页面错误</li><li>兼容性</li><li>数据（数据库）</li><li>易用性</li><li>建议</li><li>架构缺陷</li></ol></li></ol><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><blockquote><ol><li>设计用例-&gt; 执行用例（执行测试）-&gt;<strong>缺陷管理流程（提交、验证、关闭）</strong></li><li>缺陷定义：任何问题（Bug）</li><li>缺陷标准：多功能、少功能、错误、缺少隐形功能、易用性</li><li>描述缺陷重点：缺陷标题、前置条件、复现步骤、预期结果、实际结果、附件备注</li><li>提交缺陷信息：指派人、缺陷等级、修复优先级、类型、状态（统计缺陷）</li></ol></blockquote><h4 id="缺陷编写"><a href="#缺陷编写" class="headerlink" title="缺陷编写"></a>缺陷编写</h4><ol><li>缺陷报告示例</li></ol><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1665670459138.png" alt="1665670459138"></p><ol start="2"><li>缺陷跟踪流程</li></ol><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1665670437803.png" alt="1665670437803"></p><ol start="3"><li>提交缺陷注意事项</li></ol><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1665670593092.png" alt="1665670593092"></p><blockquote><p>当你发现缺陷后，首先会怎么做</p><p>确认缺陷可复现，确实是 bug，提交。</p><p>提交时，要检查缺陷是否已存在</p></blockquote><ol start="4"><li>缺陷编写规范</li></ol><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1665670868842.png" alt="1665670868842"></p><h4 id="缺陷管理"><a href="#缺陷管理" class="headerlink" title="缺陷管理"></a>缺陷管理</h4><blockquote><ol><li>项目管理工具——管理缺陷（禅道、JIRA、TFS）</li><li>Excel管理缺陷</li></ol></blockquote><h4 id="缺陷标题拓展"><a href="#缺陷标题拓展" class="headerlink" title="缺陷标题拓展"></a>缺陷标题拓展</h4><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1665673041811.png" alt="1665673041811"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;能够说出软件缺陷判定标准&lt;/li&gt;
&lt;li&gt;能够说出项目中缺陷的管理流程&lt;/li&gt;
&lt;li&gt;能够使用Excel对</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="软件测试" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>软件测试（二）</title>
    <link href="http://example.com/post/78a4925b.html"/>
    <id>http://example.com/post/78a4925b.html</id>
    <published>2022-10-10T08:02:32.000Z</published>
    <updated>2022-11-17T15:40:54.445Z</updated>
    
    <content type="html"><![CDATA[<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ol><li>能对穷举场景设计测试点</li><li>能对限定边界规则设计测试点</li><li>能对多条件依赖关系进行设计测试点</li><li>能对于项目业务进行设计测试点</li></ol><hr><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><p>等价类划分法</p></li><li><p>边界值分析法</p></li><li><p> 判定表法</p></li><li><p>场景法</p></li><li><p>错误推测法</p></li><li><p>案例</p></li></ul><h4 id="等价类划分法"><a href="#等价类划分法" class="headerlink" title="等价类划分法"></a>等价类划分法</h4><ol><li><p>说明|分类|步骤</p><ul><li>说明：在所有测试数据中，具有某种共同特征的数据集合进行划分。</li><li>分类：<strong>有效等价类</strong>：满足需求的数据集合；<strong>无效等价类</strong>：不满足需求的数据集合</li><li>步骤：<ol><li>明确需求</li><li>确定有效和无效等价类</li><li>提取数据编写测试用例</li></ol></li></ul></li><li><p>案例</p></li><li><p>使用场景</p><ul><li>针对：需要有大量数据测试输入，但是没法穷举测试的地方<ul><li>输入框</li><li>下拉列表</li><li>单选复选框</li></ul></li><li>典型代表：页面的输入框类测试</li></ul></li></ol><h4 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h4><ol><li>边界范围节点<ul><li>选取正好等于、刚好大于、刚好小于边界的值作为测试数据 <ul><li>上点：边界上的点（正好等于）</li><li>离点：距离上点最近的点（刚好大于、刚好小于）</li><li>内点：范围内的点（区间范围内的数据） </li></ul></li></ul></li><li>应用设计步骤<ol><li>明确需求</li><li>确定有效和无效等价类</li><li>确定边界范围值</li><li>提取数据编写测试用例</li></ol></li><li>案例优化<ul><li>结论：7个优化为5个点</li><li>上点：必选</li><li>内点： 必选</li><li>离点：开内闭外（考虑开闭区间，开区间选择内部离点，闭区间选择外部离点）</li></ul></li><li>适用场景<ul><li>在等价类的基础上针对有边界范围的测试数据输入的地方（重点关注边界）</li><li>常见词语描述：大小、尺寸、重量、最大、最小、至多、至少等修饰词语</li><li>典型代表：有边界范围的输入框类测试</li></ul></li></ol><h4 id="判定表法"><a href="#判定表法" class="headerlink" title="判定表法"></a>判定表法</h4><ol><li><p>判定表法的引入</p></li><li><p>判定表定义及组成部分</p><ol><li>定义：是一种以表格形式表达多条件逻辑判断的工具</li><li>组成：<ul><li>条件桩：列出问题中的所有条件，列出条件的次序无关紧要</li><li>动作桩：列出问题中可能采取的操作，操作的排序顺序没有约束</li><li>条件项：列出条件对应的取值，所有可能情况下的真假值</li><li>动作项： 列出条件项的、各种取值情况下应该采取的动作结果</li></ul><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1665564771350.png" alt="1665564771350"></li><li>规则：<ul><li>判定表中贯穿条件项和动作项的一列就是一条规则</li><li>假设有n个条件，每个条件的取值有两个（0，1），全组合有2的n次方种规则</li></ul></li></ol></li><li><p>判定表法设计用例步骤</p><ol><li>明确需求</li><li>画出判定表<ol><li>列出条件桩和动作桩</li><li>填写条件项，对条件进行全组合</li><li>根据条件项的组合确定动作项</li><li>简化、合并相似规则</li></ol></li><li>根据规则编写测试用例</li></ol></li><li><p>案例 </p></li><li><p>使用场景</p><ul><li>有多个输入条件，多个输出结果，输入条件之间有组合关系，输入条件和输出结果之间有依赖（制约）关系</li><li>判定表一般适用于条件组合数量较少的情况</li></ul></li></ol><h4 id="场景法"><a href="#场景法" class="headerlink" title="场景法"></a>场景法</h4><ol><li><p>介绍</p><ul><li>说明：场景法也可以叫流程图法，是用流程图描述用户的使用场景，然后通过覆盖流程路径来设计测试用例。</li><li>意义：<ul><li>用户使用角度：用户平时使用的不是单个功能，而是多个功能组合起来进行使用</li><li>测试人员角度：平时测试的都是单个功能点进行测试，容易忽略多个功能的组合测试</li></ul></li></ul></li><li><p>适用场景：根据实际的应用场景，来测试业务用例，可以使用场景法</p></li><li><p>流程图</p><ul><li>重点：<ul><li>覆盖业务测试需要使用流程图法</li><li>先测试业务，再测试单功能、单模块、单页面</li></ul></li><li>流程图：业务用例是根据流程图来梳理的，需要先了解流程图。流程图用来梳理业务用例</li></ul></li></ol><h4 id="错误推荐法"><a href="#错误推荐法" class="headerlink" title="错误推荐法"></a>错误推荐法</h4><blockquote><p>应用场景：当项目用例都执行完毕，且BUG修复完成，离上线还有一段时间，在这段时间中可是使用错误推荐法复测主要业务或测试未覆盖的功能。</p></blockquote><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1665586856456.png" alt="1665586856456"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;能对穷举场景设计测试点&lt;/li&gt;
&lt;li&gt;能对限定边界规则设计测试点&lt;/li&gt;
&lt;li&gt;能对多条件依赖关系进行设</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="软件测试" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>软测学习（一）</title>
    <link href="http://example.com/post/894783f1.html"/>
    <id>http://example.com/post/894783f1.html</id>
    <published>2022-10-10T02:49:46.000Z</published>
    <updated>2022-11-17T15:32:42.776Z</updated>
    
    <content type="html"><![CDATA[<h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ol><li>能复述软件测试的定义</li><li>能说出7中测试分类的区别</li><li>能说出质量模型的重点5项</li><li>能说出测试流程的6个步骤</li><li>能说出测试模块8个要素</li></ol><hr><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li>认识软件及测试</li><li>测试主流技能</li><li>常见的测试分类</li><li>测试模型</li><li>软件测试流程</li><li>测试用例</li></ul><h4 id="认识软件及测试"><a href="#认识软件及测试" class="headerlink" title="认识软件及测试"></a>认识软件及测试</h4><ul><li><p>什么是软件——控制计算机硬件工作的工具</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1665372799529.png" alt="1665372799529"></p></li><li><p>软件的基本组成</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1665374340234.png" alt="1665374340234"></p></li><li><p>软件产生过程</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1665374397708.png" alt="1665374397708"></p></li><li><p>什么是软件测试</p><p>使用<strong>技术</strong>手段<strong>验证</strong>软件是否满足使用需求</p></li><li><p>软件测试目的</p><p> 减少软件<strong>缺陷</strong>（bug），保障软件质量</p></li></ul><h4 id="测试主流技能"><a href="#测试主流技能" class="headerlink" title="测试主流技能"></a>测试主流技能</h4><ul><li><p>功能测试</p></li><li><p>自动化测试</p><p>使用<strong>代码或工具</strong>代替手工，对项目进行测试</p></li><li><p>接口测试</p><p>使用<strong>代码或工具</strong>对服务端的接口进行测试</p></li><li><p>性能测试</p><p>模拟<strong>多人</strong>使用软件，查找服务器缺陷</p></li></ul><h4 id="常见的测试分类"><a href="#常见的测试分类" class="headerlink" title="常见的测试分类"></a>常见的测试分类</h4><h5 id="按阶段划分"><a href="#按阶段划分" class="headerlink" title="按阶段划分"></a>按阶段划分</h5><ul><li><p>单元测试：针对<strong>源代码</strong>进行测试</p></li><li><p>集成测试：针对<strong>接口</strong>进行测试</p></li><li><p>系统测试：针对<strong>功能和非功能</strong>进行测试</p></li><li><p>验收测试：内侧、公测</p></li></ul><h5 id="按代码可见度划分"><a href="#按代码可见度划分" class="headerlink" title="按代码可见度划分"></a>按代码可见度划分</h5><ul><li>黑盒测试：不关注源代码，针对<strong>程序UI功能</strong>测试（系统测试）</li><li>灰盒测试：针对<strong>程序部分代码</strong>进行测试（集成测试）</li><li>白盒测试：针对<strong>源代码</strong>进行测试（单元测试）</li></ul><h4 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h4><p><strong>质量模型——衡量一个优秀软件的维度</strong></p><ol><li><p><strong>功能性</strong></p></li><li><p><strong>性能性</strong></p></li><li><p><strong>兼容性</strong> </p></li><li><p><strong>易用性</strong></p></li><li><p><strong>安全性</strong></p></li><li><p>可靠性</p></li><li><p>移植性</p></li><li><p>维护性</p></li></ol><h4 id="软件测试流程"><a href="#软件测试流程" class="headerlink" title="软件测试流程"></a>软件测试流程</h4><ol><li><p>需求评审：确保各部门需求理解一致</p></li><li><p>计划编写：测什么、谁来测、怎么测</p></li><li><p>用例设计：验证项目是否符合需求的操作文档</p></li><li><p>用例执行：项目模块开发完成开始执行用例文档实施测试</p></li><li><p>缺陷管理：对缺陷进行管理的过程</p></li><li><p>测试报告：实施测试结构文档</p></li></ol><h4 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h4><ul><li><p>什么是用例：用户使用的案例</p><p><img src="https://jjjj1990.oss-cn-hangzhou.aliyuncs.com/img/1665383766953.png" alt="1665383766953"></p></li><li><p>什么是测试用例：是为测试项目而设计的执行文档</p></li><li><p>测试用例的作用：防止漏测、实施测试的标准 </p></li><li><p>用例编写格式</p><ul><li><strong>用例编号</strong>：项目简称<code>_</code>模块简称<code>_</code>编号</li><li><strong>用例标题</strong>：预期结果（测试点）</li><li><strong>模块/项目</strong>：用例所属项目或模块</li><li><strong>优先级</strong>：表示用例的重要程度或者影响力P0~P4(P0最高)</li><li><strong>前置条件</strong>：要执行此条用例，有哪些前置操作</li><li><strong>测试步骤</strong>：描述操作步骤</li><li><strong>测试数据</strong>：执行步骤中的重点数据，没有的话可以为空</li><li><strong>预期结果</strong>：用例执行结果+不同角色隐性结果</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;学习目标&quot;&gt;&lt;a href=&quot;#学习目标&quot; class=&quot;headerlink&quot; title=&quot;学习目标&quot;&gt;&lt;/a&gt;学习目标&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;能复述软件测试的定义&lt;/li&gt;
&lt;li&gt;能说出7中测试分类的区别&lt;/li&gt;
&lt;li&gt;能说出质量模型的重点5项&lt;/</summary>
      
    
    
    
    <category term="笔记" scheme="http://example.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="软件测试" scheme="http://example.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>javaScript</title>
    <link href="http://example.com/post/834695c1.html"/>
    <id>http://example.com/post/834695c1.html</id>
    <published>2022-10-02T09:42:03.000Z</published>
    <updated>2022-10-02T09:51:29.242Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="一、JavaScript语法"><a href="#一、JavaScript语法" class="headerlink" title="一、JavaScript语法"></a>一、JavaScript语法</h1><h2 id="1-初始JavaScript"><a href="#1-初始JavaScript" class="headerlink" title="1 - 初始JavaScript"></a>1 - 初始JavaScript</h2><h3 id="1-1-JavaScript-是什么"><a href="#1-1-JavaScript-是什么" class="headerlink" title="1.1 JavaScript 是什么"></a>1.1 JavaScript 是什么</h3><ul><li>JavaScript 是世界上最流行的语言之一，是一种运行在客户端的脚本语言 （Script 是脚本的意思）</li><li>脚本语言：不需要编译，运行过程中由 js 解释器( js 引擎）逐行来进行解释并执行</li><li>现在也可以基于 Node.js 技术进行服务器端编程</li></ul><h3 id="1-2-JavaScript的作用"><a href="#1-2-JavaScript的作用" class="headerlink" title="1.2 JavaScript的作用"></a>1.2 JavaScript的作用</h3><ul><li>表单动态校验（密码强度检测）  （ JS 产生最初的目的 ）</li><li>网页特效</li><li>服务端开发(Node.js)</li><li>桌面程序(Electron)</li><li>App(Cordova) </li><li>控制硬件-物联网(Ruff)</li><li>游戏开发(cocos2d-js)</li></ul><h3 id="1-3-HTML-CSS-JS-的关系"><a href="#1-3-HTML-CSS-JS-的关系" class="headerlink" title="1.3 HTML/CSS/JS 的关系"></a>1.3 HTML/CSS/JS 的关系</h3><p><img src="D:\桌面\学习\前端\笔记\images\1_3.png"></p><h3 id="1-4-浏览器执行-JS-简介"><a href="#1-4-浏览器执行-JS-简介" class="headerlink" title="1.4 浏览器执行 JS 简介"></a>1.4 浏览器执行 JS 简介</h3><p><strong>浏览器分成两部分：渲染引擎和 JS 引擎</strong></p><table><thead><tr><th>组成</th><th>介绍</th></tr></thead><tbody><tr><td>渲染引擎</td><td>用来解析HTML与CSS，俗称内核，比如chrome浏览器的blink，老版本的webkit</td></tr><tr><td>js引擎</td><td>也称Js解释器。用来读取网页中的js代码，对其处理后运行，比如chrome浏览器的V8</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。</span><br></pre></td></tr></table></figure><h3 id="1-5-JS-的组成"><a href="#1-5-JS-的组成" class="headerlink" title="1.5 JS 的组成"></a>1.5 JS 的组成</h3><table><thead><tr><th align="center">Js组成</th><th align="left">介绍</th></tr></thead><tbody><tr><td align="center">ECMAScript——js语法</td><td align="left"><strong>ECMAScript</strong> 是由ECMA 国际（ 原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为 JavaScript或 JScript，但实际上后两者是 ECMAScript 语言的实现和扩展。规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准。更多参看MDN: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/JavaScript_technologies_overview">MDN手册</a></td></tr><tr><td align="center">DOM——文档对象模型</td><td align="left"><strong>文档对象模型</strong>（DocumentObject Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过 DOM 提供的接口可以对页面上的各种元素进行操作（大小、位置、颜色等）</td></tr><tr><td align="center">BOM——浏览器对象模型</td><td align="left"><strong>浏览器对象模型</strong>(Browser Object Model，简称BOM) 是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。</td></tr></tbody></table><h3 id="1-6-JS-初体验"><a href="#1-6-JS-初体验" class="headerlink" title="1.6 JS 初体验"></a>1.6 JS 初体验</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JS 有3种书写位置，分别为行内、内嵌和外部。（与css几乎一样）</span><br></pre></td></tr></table></figure><ol><li><p>行内式</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点我试试&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;alert(&#x27;Hello World&#x27;)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以将单行或少量 JS 代码写在HTML标签的事件属性中（以 on 开头的属性），如：onclick</li><li>注意单双引号的使用：在HTML中我们推荐使用双引号, JS 中我们推荐使用单引号</li><li>可读性差， 在html中编写JS大量代码时，不方便阅读；</li><li>引号易错，引号多层嵌套匹配时，非常容易弄混；</li><li>特殊情况下使用</li></ul></li><li><p>内嵌式</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">alert</span>(<span class="string">&#x27;Hello  World~!&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>可以将多行JS代码写到 script 标签中</li><li>内嵌 JS 是学习时常用的方式</li></ul></li><li><p>外部JS文件</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;my.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>利于HTML页面代码结构化，把大段 JS代码独立到 HTML 页面之外，既美观，也方便文件级别的复用</li><li>引用外部 JS文件的 script 标签中间不可以写代码</li><li>适合于JS 代码量比较大的情况</li></ul></li></ol><h2 id="2-JavaScript输入输出语句"><a href="#2-JavaScript输入输出语句" class="headerlink" title="2 - JavaScript输入输出语句"></a>2 - JavaScript输入输出语句</h2><p>为了方便信息的输入输出，JS中提供了一些输入输出语句，其常用的语句如下：</p><table><thead><tr><th>方法</th><th>说明</th><th>归属</th></tr></thead><tbody><tr><td>alert(msg)</td><td>浏览器弹出警示框</td><td>浏览器</td></tr><tr><td>console.log(msg)</td><td>浏览器控制台打印输出信息</td><td>浏览器</td></tr><tr><td>prompt(info)</td><td>浏览器弹出输入框，用户可以输入</td><td>浏览器</td></tr></tbody></table><ul><li>注意：alert() 主要用来显示消息给用户，console.log() 用来给程序员自己看运行时的消息。</li></ul><h2 id="3-变量命名规范"><a href="#3-变量命名规范" class="headerlink" title="3 - 变量命名规范"></a>3 - 变量命名规范</h2><ul><li>由字母(A-Za-z)、数字(0-9)、下划线(_)、美元符号( $ )组成，如：usrAge, num01, _name</li><li>严格区分大小写。var app; 和 var App; 是两个变量</li><li>不能 以数字开头。  18age   是错误的</li><li>不能 是关键字、保留字。例如：var、for、while</li><li>变量名必须有意义。 MMD   BBD        nl   →     age  </li><li>遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。myFirstName</li></ul><h2 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4 - 数据类型"></a>4 - 数据类型</h2><h3 id="4-1-数据类型简介"><a href="#4-1-数据类型简介" class="headerlink" title="4.1 数据类型简介"></a>4.1 数据类型简介</h3><ul><li><p>变量的数据类型</p><pre><code>    变量是用来存储值的所在处，它们有名字和数据类型。变量的数据类型决定了如何将代表这些值的位存储到计算机的内存中。JavaScript 是一种弱类型或者说动态语言。这意味着**不用提前声明变量的类型**，在程序运行过程中，类型会被自动确定：</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>;        <span class="comment">// 这是一个数字型</span></span><br><span class="line"><span class="keyword">var</span> areYouOk = <span class="string">&#x27;是的&#x27;</span>;   <span class="comment">// 这是一个字符串     </span></span><br></pre></td></tr></table></figure><pre><code>    在代码运行时，变量的数据类型是由 JS引擎 根据等号**右边变量值的数据类型来判断**的，运行完毕之后， 变量就确定了数据类型。JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型：</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">6</span>;           <span class="comment">// x 为数字</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">&quot;Bill&quot;</span>;      <span class="comment">// x 为字符串    </span></span><br></pre></td></tr></table></figure></li><li><p>数据类型的分类</p><p>JS 把数据类型分为两类：</p><ul><li>简单数据类型 （Number,String,Boolean,Undefined,Null）</li><li>复杂数据类型 （object 对象)    </li></ul></li></ul><h3 id="4-2-简单数据类型"><a href="#4-2-简单数据类型" class="headerlink" title="4.2 简单数据类型"></a>4.2 简单数据类型</h3><p>简单数据类型（基本数据类型）</p><p>JavaScript 中的简单数据类型及其说明如下：</p><table><thead><tr><th>简单数据类型</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>Number</td><td>数字型，包含 整型值和浮点值，如21，0.21</td><td>0</td></tr><tr><td>Boolean</td><td>布尔值类型，如ture，false，等价于1和0</td><td>false</td></tr><tr><td>String</td><td>字符串类型，如”张三“</td><td>“ “</td></tr><tr><td>Undefined</td><td>var a；声明了变量a但没有值，此时a = undefined</td><td>undefined</td></tr><tr><td>Null</td><td>var a = null；声明了变量a为空值</td><td>null</td></tr></tbody></table><ul><li><p>数字型 Number</p><pre><code>    JavaScript 数字类型既可以保存整数，也可以保存小数(浮点数）。  </code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">21</span>;       <span class="comment">// 整数</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Age</span> = <span class="number">21.3747</span>;  <span class="comment">// 小数     </span></span><br></pre></td></tr></table></figure><ol><li><p>数字型进制</p><p>最常见的进制有二进制、八进制、十进制、十六进制。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 1.八进制数字序列范围：0~7</span></span><br><span class="line"><span class="keyword">var</span> num1 = <span class="number">07</span>;   <span class="comment">// 对应十进制的7</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="number">019</span>;  <span class="comment">// 对应十进制的19</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="number">08</span>;   <span class="comment">// 对应十进制的8</span></span><br><span class="line"> <span class="comment">// 2.十六进制数字序列范围：0~9以及A~F</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">0xA</span>;   </span><br></pre></td></tr></table></figure></li><li><p>数字型范围</p><p>JavaScript中数值的最大和最小值</p><ul><li>最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308</li><li>最小值：Number.MIN_VALUE，这个值为：5e-32</li></ul></li></ol></li></ul><ol start="3"><li><p>数字型三个特殊值</p><ul><li>Infinity ，代表无穷大，大于任何数值</li><li>-Infinity ，代表无穷小，小于任何数值</li><li>NaN ，Not a number，代表一个非数值</li></ul></li><li><p>isNaN</p><p>用来判断一个变量是否为非数字的类型，返回 true 或者 false</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> usrAge = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">var</span> isOk = <span class="built_in">isNaN</span>(userAge);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(isNum);          <span class="comment">// false ，21 不是一个非数字</span></span><br><span class="line"><span class="keyword">var</span> usrName = <span class="string">&quot;andy&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">isNaN</span>(userName));<span class="comment">// true ，&quot;andy&quot;是一个非数字</span></span><br></pre></td></tr></table></figure><ul><li><p>字符串型 String</p><p>字符串型可以是引号中的任意文本，其语法为 双引号 “” 和 单引号’’</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strMsg = <span class="string">&quot;我爱北京天安门~&quot;</span>;  <span class="comment">// 使用双引号表示字符串</span></span><br><span class="line"><span class="keyword">var</span> strMsg2 = <span class="string">&#x27;我爱吃猪蹄~&#x27;</span>;    <span class="comment">// 使用单引号表示字符串</span></span><br><span class="line"><span class="comment">// 常见错误</span></span><br><span class="line"><span class="keyword">var</span> strMsg3 = 我爱大肘子;       <span class="comment">// 报错，没使用引号，会被认为是js代码，但js没有这些语法</span></span><br></pre></td></tr></table></figure><p>因为 HTML 标签里面的属性使用的是双引号，JS 更适合使用单引号。</p><ol><li><p>字符串引号嵌套</p><pre><code>    JS 可以用单引号嵌套双引号 ，或者用双引号嵌套单引号 (外双内单，外单内双)</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strMsg = <span class="string">&#x27;我是&quot;高帅富&quot;程序猿&#x27;</span>;   <span class="comment">// 可以用&#x27;&#x27;包含&quot;&quot;</span></span><br><span class="line"><span class="keyword">var</span> strMsg2 = <span class="string">&quot;我是&#x27;高帅富&#x27;程序猿&quot;</span>;  <span class="comment">// 也可以用&quot;&quot; 包含&#x27;&#x27;</span></span><br><span class="line"><span class="comment">//  常见错误</span></span><br><span class="line"><span class="keyword">var</span> badQuotes = <span class="string">&#x27;What on earth?&quot;; // 报错，不能 单双引号搭配</span></span><br></pre></td></tr></table></figure></li><li><p>字符串转义符</p><pre><code>    类似HTML里面的特殊字符，字符串中也有特殊字符，我们称之为转义符。       转义符都是 \ 开头的，常用的转义符及其说明如下：</code></pre><table><thead><tr><th>转义符</th><th>解释说明</th></tr></thead><tbody><tr><td>\n</td><td>换行符，n   是   newline   的意思</td></tr><tr><td>\ \</td><td>斜杠   \</td></tr><tr><td>&#39;</td><td>‘   单引号</td></tr><tr><td>&quot;</td><td>”双引号</td></tr><tr><td>\t</td><td>tab  缩进</td></tr><tr><td>\b</td><td>空格 ，b   是   blank  的意思</td></tr></tbody></table></li><li><p>字符串长度</p><pre><code>    字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 **length** 属性可以获取整个字符串的长度。</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> strMsg = <span class="string">&quot;我是帅气多金的程序猿！&quot;</span>;</span><br><span class="line"><span class="title function_">alert</span>(strMsg.<span class="property">length</span>); <span class="comment">// 显示 11</span></span><br></pre></td></tr></table></figure></li><li><p>字符串拼接</p><ul><li><p>多个字符串之间可以使用 + 进行拼接，其拼接方式为 字符串 + 任何类型 = 拼接之后的新字符串</p></li><li><p>拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.1 字符串 &quot;相加&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;hello&#x27;</span> + <span class="string">&#x27; &#x27;</span> + <span class="string">&#x27;world&#x27;</span>); <span class="comment">// hello world</span></span><br><span class="line"><span class="comment">//1.2 数值字符串 &quot;相加&quot;</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;100&#x27;</span> + <span class="string">&#x27;100&#x27;</span>); <span class="comment">// 100100</span></span><br><span class="line"><span class="comment">//1.3 数值字符串 + 数值</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;11&#x27;</span> + <span class="number">12</span>);     <span class="comment">// 1112 </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我已经&#x27;</span> + <span class="number">18</span>);        <span class="comment">// 只要有字符就会相连 </span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我已经age岁啦&#x27;</span>);      <span class="comment">// 错误，引号里面不放变量</span></span><br></pre></td></tr></table></figure></li></ul></li></ol></li><li><p>布尔型Boolean</p><pre><code>    布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。      布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> + <span class="number">1</span>);  <span class="comment">// 2</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">false</span> + <span class="number">1</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p>Undefined和 Null</p><pre><code>    一个声明后没有被赋值的变量会有一个默认值undefined ( 如果进行相连或者相加时，注意结果）</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(variable);           <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;你好&#x27;</span> + variable);  <span class="comment">// 你好undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11</span> + variable);     <span class="comment">// NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> + variable);   <span class="comment">//  NaN</span></span><br></pre></td></tr></table></figure><pre><code>    一个声明变量给 null 值，里面存的值为空（学习对象时，我们继续研究null)</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vari = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;你好&#x27;</span> + vari);  <span class="comment">// 你好null</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">11</span> + vari);     <span class="comment">// 11</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> + vari);   <span class="comment">//  1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="4-3-获取变量数据类型"><a href="#4-3-获取变量数据类型" class="headerlink" title="4.3 获取变量数据类型"></a>4.3 获取变量数据类型</h3><ul><li><p>获取检测变量的数据类型</p><pre><code>    **typeof** 可用来获取检测变量的数据类型</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">18</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> num) <span class="comment">// 结果 number      </span></span><br></pre></td></tr></table></figure></li><li><p>字面量</p><pre><code>    字面量是在源代码中一个固定值的表示法，通俗来说，就是字面量表示如何表达这个值。</code></pre><ul><li>数字字面量：8, 9, 10</li><li>字符串字面量：’黑马程序员’, “大前端”</li><li>布尔字面量：true，false</li></ul></li></ul><h3 id="4-4-数据类型转换"><a href="#4-4-数据类型转换" class="headerlink" title="4.4 数据类型转换"></a>4.4 数据类型转换</h3><pre><code>    什么是数据类型转换？    使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成另一种数据类型，通常会实现3种方式的转换：</code></pre><blockquote><p>转换为字符串类型<br>转换为数字型<br>转换为布尔型</p></blockquote><ul><li><p>转换为字符串</p><table><thead><tr><th>方式</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td>toString()</td><td>转成字符串</td><td>var num = 1; alert(<strong>num.toString()</strong>);</td></tr><tr><td>String()  强制转换</td><td>转成字符串</td><td>var num = 1;alert(<strong>String(num)</strong>);</td></tr><tr><td>加号拼接字符串</td><td>和字符拼接的结果都是字符串</td><td>var num = 1;alert(num +  “字符串”)</td></tr></tbody></table><ul><li>toString() 和 String()  使用方式不一样，注意。</li><li>三种转换方式，更多第三种加号拼接字符串转换方式， 这一种方式也称之为隐式转换。</li></ul></li><li><p>转换为数字型<strong>（重点）</strong></p><table><thead><tr><th>方式</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td>parseInt()</td><td>将其他类型转成整型数值型</td><td>parselnt(‘78’)</td></tr><tr><td>parseFloat()</td><td>将其他类型转成浮点型数值型</td><td>parseFloat(‘78.1)</td></tr><tr><td>Number() 强制转换</td><td>将其他类型转成数值型</td><td>Number(’12‘)</td></tr><tr><td>隐式转换</td><td>利用算术运算隐式转成数值型</td><td>’12‘ - 0</td></tr></tbody></table><ul><li>注意 parseInt 和 parseFloat 单词的大小写，这2个是重点</li><li>隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型</li></ul></li><li><p>转换为布尔型</p><table><thead><tr><th>方式</th><th>说明</th><th>案例</th></tr></thead><tbody><tr><td>Boolean()</td><td>将其他类型转化为布尔型</td><td>Boolean(‘true’)</td></tr></tbody></table><ul><li><p>代表空、否定的值会被转换为 false  ，如 ‘’0、NaN、null、undefined  “</p></li><li><p>其余值都会被转换为 true</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&#x27;&#x27;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="title class_">NaN</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="literal">null</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="literal">undefined</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="string">&#x27;小白&#x27;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Boolean</span>(<span class="number">12</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="5-关键字和保留字"><a href="#5-关键字和保留字" class="headerlink" title="5 - 关键字和保留字"></a>5 - 关键字和保留字</h2><h3 id="5-1-标识符"><a href="#5-1-标识符" class="headerlink" title="5.1 标识符"></a>5.1 标识符</h3><blockquote><p>标识(zhi)符：就是指开发人员为变量、属性、函数、参数取的名字。</p><p>标识符不能是关键字或保留字。</p></blockquote><h3 id="5-2-关键字"><a href="#5-2-关键字" class="headerlink" title="5.2 关键字"></a>5.2 关键字</h3><blockquote><p>关键字：是指 JS本身已经使用了的字，不能再用它们充当变量名、方法名。</p><p>包括：break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with 等。</p></blockquote><h3 id="5-3-保留字"><a href="#5-3-保留字" class="headerlink" title="5.3 保留字"></a>5.3 保留字</h3><blockquote><p>保留字：实际上就是预留的“关键字”，意思是现在虽然还不是关键字，但是未来可能会成为关键字，同样不能使用它们当变量名或方法名。</p><p>包括：boolean、byte、char、class、const、debugger、double、enum、export、extends、fimal、float、goto、implements、import、int、interface、long、mative、package、private、protected、public、short、static、super、synchronized、throws、transient、volatile 等。</p><p>注意：如果将保留字用作变量名或函数名，那么除非将来的浏览器实现了该保留字，否则很可能收不到任何错误消息。当浏览器将其实现后，该单词将被看做关键字，如此将出现关键字错误。</p></blockquote><h2 id="6-运算符"><a href="#6-运算符" class="headerlink" title="6 -运算符"></a>6 -运算符</h2><ul><li>算数运算符</li><li>递增和递减运算符</li><li>比较运算符</li><li>逻辑运算符</li><li>赋值运算符</li></ul><p> 运算符优先级</p><table><thead><tr><th>优先级</th><th>运算符</th><th>顺序</th></tr></thead><tbody><tr><td>1</td><td>小括号</td><td>()</td></tr><tr><td>2</td><td>一元运算符</td><td>++  –  !</td></tr><tr><td>3</td><td>算数运算符</td><td>* / % + -</td></tr><tr><td>4</td><td>关系运算符</td><td>&gt;   &gt;=    &lt;   &lt;=</td></tr><tr><td>5</td><td>相等运算符</td><td>== !=   ===     !==</td></tr><tr><td>6</td><td>逻辑运算符</td><td>&amp;&amp;   ||</td></tr><tr><td>7</td><td>赋值运算符</td><td>=</td></tr><tr><td>8</td><td>逗号运算符</td><td>,</td></tr></tbody></table><ul><li> 全等于（===（类型和值））</li></ul><p>1、如果类型不同，就[不相等]</p><p>2、如果两个都是数值，并且是同一个值，那么[相等]；(！例外)的是，如果其中至少一个是NaN，那么[不相等]。（判断一个值是否是NaN，只能用isNaN()来判断）</p><p>3、如果两个都是字符串，每个位置的字符都一样，那么[相等]；否则[不相等]。</p><p>4、如果两个值都是true，或者都是false，那么[相等]。</p><p>5、如果两个值都引用同一个对象或函数，那么[相等]；否则[不相等]。</p><p>6、如果两个值都是null，或者都是undefined，那么[相等]。</p><ul><li>等于（==（值））</li></ul><p>1、如果两个值类型相同，进行 === 比较。</p><p>2、如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较：</p><pre><code>a、如果一个是null、一个是undefined，那么[相等]。b、如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。c、如果任一值是 true ，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。d、如果一个是对象，另一 个是数值或字符串，把对象转换成基础类型的值再比较。*对象转换成基础          类型，利用它的toString或者valueOf方法。js核心内置类，会尝试 valueOf先于toString；例外的          是Date，Date利用的是toString转换。*e、任何其他组合，都[不相等]。</code></pre><h2 id="7-流程控制"><a href="#7-流程控制" class="headerlink" title="7 -流程控制"></a>7 -流程控制</h2><ul><li>顺序流程控制</li><li>分支流程控制<ul><li>if else</li><li>switch分支</li></ul></li><li>循环流程控制<ul><li>while</li><li>for</li><li>do while</li></ul></li></ul><h2 id="8-数组"><a href="#8-数组" class="headerlink" title="8 -数组"></a>8 -数组</h2><ul><li>数组可以把一组相关的数据一起存放，并提供方便的访问(获取）方式。</li><li>数组是指<strong>一组数据的集合</strong>，其中的每个数据被称作<strong>元素</strong>，在数组中可以<strong>存放任意类型的元素</strong>。数组是一种将一组数据存储在单个变量名下的优雅方式。</li></ul><h3 id="8-2-创建数组"><a href="#8-2-创建数组" class="headerlink" title="8.2 创建数组"></a>8.2 创建数组</h3><p>JS 中创建数组有两种方式：</p><ul><li><p>利用  new 创建数组  </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//var 数组名 = new Array() ；</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>();   <span class="comment">// 创建一个新的空数组</span></span><br></pre></td></tr></table></figure><p>注意 <strong>Array () ，A 要大写</strong>    </p></li><li><p>利用数组字面量创建数组</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 使用数组字面量方式创建空的数组</span></span><br><span class="line"><span class="keyword">var</span>  数组名 = []；</span><br><span class="line"><span class="comment">//2. 使用数组字面量方式创建带初始值的数组</span></span><br><span class="line"><span class="keyword">var</span>  数组名 = [<span class="string">&#x27;小白&#x27;</span>,<span class="string">&#x27;小黑&#x27;</span>,<span class="string">&#x27;大黄&#x27;</span>,<span class="string">&#x27;瑞奇&#x27;</span>];</span><br></pre></td></tr></table></figure><ul><li>数组的字面量是方括号 [ ] </li><li>声明数组并赋值称为数组的初始化</li><li>这种字面量方式也是我们以后最多使用的方式</li></ul></li><li><p>数组元素的类型</p><p><strong>数组中可以存放任意类型的数据</strong>，例如字符串，数字，布尔值等。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrStus = [<span class="string">&#x27;小白&#x27;</span>,<span class="number">12</span>,<span class="literal">true</span>,<span class="number">28.9</span>];</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-3-获取数组中的元素"><a href="#8-3-获取数组中的元素" class="headerlink" title="8.3 获取数组中的元素"></a>8.3 获取数组中的元素</h3><pre><code>    索引 (下标) ：用来访问数组元素的序号（数组下标从 0 开始）。    数组可以通过索引来访问、设置、修改对应的数组元素，可以通过“数组名[索引]”的形式来获取数组中的元素。</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义数组</span></span><br><span class="line"><span class="keyword">var</span> arrStus = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 获取数组中的第2个元素</span></span><br><span class="line"><span class="title function_">alert</span>(arrStus[<span class="number">1</span>]);    </span><br></pre></td></tr></table></figure><p>注意：如果访问时数组没有和索引值对应的元素，则得到的值是<strong>undefined</strong></p><h3 id="1-4-遍历数组"><a href="#1-4-遍历数组" class="headerlink" title="1.4 遍历数组"></a>1.4 遍历数组</h3><ul><li><p>数组遍历</p><pre><code>    把数组中的每个元素从头到尾都访问一次（类似学生的点名），可以通过 for 循环索引遍历数组中的每一项</code></pre></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arrStus[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>数组的长度</p><p>数组的长度：默认情况下表示数组中元素的个数</p><p>使用<strong>“数组名.length”</strong>可以访问数组元素的数量（数组长度）。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arrStus = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="title function_">alert</span>(arrStus.<span class="property">length</span>);  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p>当我们数组里面的元素个数发生了变化，这个 length 属性跟着一起变化</p><ul><li><strong>数组的length属性可以被修改：</strong></li></ul></li><li><p>如果设置的length属性值大于数组的元素个数，则会在数组末尾出现空白元素；</p><ul><li>如果设置的length属性值小于数组的元素个数，则会把超过该值的数组元素删除</li></ul></li></ul><h3 id="1-5-数组中新增元素"><a href="#1-5-数组中新增元素" class="headerlink" title="1.5 数组中新增元素"></a>1.5 数组中新增元素</h3><pre><code>    数组中可以通过以下方式在数组的**末尾**插入新元素：</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">数组[ 数组.<span class="property">length</span> ] = 新数据;</span><br></pre></td></tr></table></figure><h2 id="9-函数"><a href="#9-函数" class="headerlink" title="9 - 函数"></a>9 - 函数</h2><h3 id="9-1-函数的概念"><a href="#9-1-函数的概念" class="headerlink" title="9.1 函数的概念"></a>9.1 函数的概念</h3><pre><code>    在 JS 里面，可能会定义非常多的相同代码或者功能相似的代码，这些代码可能需要大量重复使用。虽然 for循环语句也能实现一些简单的重复操作，但是比较具有局限性，此时我们就可以使用 JS 中的函数。    函数：就是**封装了一段可被重复调用执行的代码块**。通过此代码块可以**实现大量代码的重复使用**。  </code></pre><h3 id="9-2-函数的使用"><a href="#9-2-函数的使用" class="headerlink" title="9.2 函数的使用"></a>9.2 函数的使用</h3><h4 id="声明函数"><a href="#声明函数" class="headerlink" title="声明函数"></a>声明函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="keyword">function</span> 函数名() &#123;</span><br><span class="line">    <span class="comment">//函数体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum</li></ul><h4 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">函数名();  <span class="comment">// 通过调用函数名来执行函数体代码</span></span><br></pre></td></tr></table></figure><ul><li>调用的时候千万不要忘记添加小括号</li></ul><h4 id="函数的封装"><a href="#函数的封装" class="headerlink" title="函数的封装"></a>函数的封装</h4><ul><li><p>函数的封装是把一个或者多个功能通过函数的方式封装起来，对外只提供一个简单的函数接口</p><p>例子：封装计算1-100累加和</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   计算1-100之间值的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> sumNum = <span class="number">0</span>;<span class="comment">// 准备一个变量，保存数字和</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">    sumNum += i;<span class="comment">// 把每个数值 都累加 到变量中</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">alert</span>(sumNum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="title function_">getSum</span>();</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-3-函数的参数"><a href="#9-3-函数的参数" class="headerlink" title="9.3 函数的参数"></a>9.3 函数的参数</h3><h4 id="函数参数语法"><a href="#函数参数语法" class="headerlink" title="函数参数语法"></a>函数参数语法</h4><ul><li><p>形参：函数<strong>定义</strong>的时候 传递的餐宿</p></li><li><p>实参：函数<strong>调用</strong>的时候 传递的参数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 带参数的函数声明</span></span><br><span class="line"><span class="keyword">function</span> 函数名(形参<span class="number">1</span>, 形参<span class="number">2</span> , 形参<span class="number">3.</span>..) &#123; <span class="comment">// 可以定义任意多的参数，用逗号分隔</span></span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 带参数的函数调用</span></span><br><span class="line">函数名(实参<span class="number">1</span>, 实参<span class="number">2</span>, 实参<span class="number">3.</span>..);</span><br></pre></td></tr></table></figure><ol><li>调用的时候实参值是传递给形参的</li><li>形参简单理解为：不用声明的变量</li><li>实参和形参的多个参数之间用逗号（,）分隔</li></ol></li></ul><h4 id="函数形参和实参数量不匹配时"><a href="#函数形参和实参数量不匹配时" class="headerlink" title="函数形参和实参数量不匹配时"></a>函数形参和实参数量不匹配时</h4><table><thead><tr><th>参数个数</th><th>说明</th></tr></thead><tbody><tr><td>实参&gt;=形参</td><td>取到形参个数，输出答案</td></tr><tr><td>实参&lt;形参</td><td>多的形参定义为undefined，结果为NaN</td></tr></tbody></table><p>注意：在JavaScript中，形参的默认值是undefined。</p><h3 id="8-4-函数的返回值"><a href="#8-4-函数的返回值" class="headerlink" title="8.4 函数的返回值"></a>8.4 函数的返回值</h3><h4 id="return-语句"><a href="#return-语句" class="headerlink" title="return 语句"></a>return 语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">返回值：函数调用整体代表的数据；函数执行完成后可以通过return语句将指定数据返回 。</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明函数</span></span><br><span class="line"><span class="keyword">function</span> 函数名（）&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span>  需要返回的值；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">函数名();    <span class="comment">// 此时调用函数就可以得到函数体内return 后面的值</span></span><br></pre></td></tr></table></figure><ul><li>在使用 return 语句时，函数会停止执行，并返回指定的值</li><li>如果函数没有 return ，返回的值是 undefined</li></ul><h4 id="break-continue-return-的区别"><a href="#break-continue-return-的区别" class="headerlink" title="break ,continue ,return 的区别"></a>break ,continue ,return 的区别</h4><ul><li>break ：结束当前的循环体（如 for、while）</li><li>continue ：跳出本次循环，继续执行下次循环（如 for、while）</li><li>return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码</li></ul><h3 id="8-5-arguments的使用"><a href="#8-5-arguments的使用" class="headerlink" title="8.5 arguments的使用"></a>8.5 arguments的使用</h3><pre><code>    当不确定有多少个参数传递的时候，可以用 arguments 来获取。JavaScript 中，arguments实际上它是当前函数的一个内置对象。所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。arguments展示形式是一个伪数组，因此可以进行遍历。伪数组具有以下特点：</code></pre><ul><li><p>具有 length 属性,如arguments.length;</p></li><li><p>按索引方式储存数据，如arguments[0];</p></li><li><p>不具有数组的 push , pop 等方法；</p><p>注意：在函数内部使用该对象，用此对象获取函数调用时传的实参。</p></li></ul><h3 id="8-6-函数的两种声明方式"><a href="#8-6-函数的两种声明方式" class="headerlink" title="8.6 函数的两种声明方式"></a>8.6 函数的两种声明方式</h3><ul><li><p>自定义函数方式(命名函数)</p><p>利用函数关键字 function 自定义函数方式</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明定义方式</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;...&#125;</span><br><span class="line"><span class="comment">// 调用  </span></span><br><span class="line"><span class="title function_">fn</span>();  </span><br></pre></td></tr></table></figure><ul><li>因为有名字，所以也被称为命名函数</li><li>调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</li></ul></li><li><p>函数表达式方式(匿名函数）</p><p>利用函数表达式方式的写法如下： </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是函数表达式写法，匿名函数后面跟分号结束</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="keyword">function</span>(<span class="params"></span>)&#123;...&#125;；</span><br><span class="line"><span class="comment">// 调用的方式，函数调用必须写到函数体下面</span></span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure><ul><li>因为函数没有名字，所以也被称为匿名函数</li><li>这个fn 里面存储的是一个函数  </li><li>函数表达式方式原理跟声明变量方式是一致的</li><li>函数调用的代码必须写到函数体后面</li></ul></li></ul><h2 id="9-作用域"><a href="#9-作用域" class="headerlink" title="9 - 作用域"></a>9 - 作用域</h2><h3 id="9-1-作用域概述"><a href="#9-1-作用域概述" class="headerlink" title="9.1 作用域概述"></a>9.1 作用域概述</h3><pre><code>    通常来说，一段程序代码中所用到的名字并不总是有效和可用的，而限定这个名字的可用性的代码范围就是这个名字的作用域。作用域的使用提高了程序逻辑的局部性，增强了程序的可靠性，减少了名字冲突。</code></pre><p>JavaScript（es6前）中的作用域有两种：</p><ul><li>全局作用域</li><li>局部作用域（函数作用域）    </li></ul><h3 id="9-2-全局作用域"><a href="#9-2-全局作用域" class="headerlink" title="9.2 全局作用域"></a>9.2 全局作用域</h3><blockquote><pre><code>作用于所有代码执行的环境(整个script标签内部)或独立的js文件。</code></pre></blockquote><h3 id="9-3-局部作用域"><a href="#9-3-局部作用域" class="headerlink" title="9.3 局部作用域"></a>9.3 局部作用域</h3><blockquote><pre><code>作用于函数内的代码环境，就是局部作用域。     因为跟函数有关系，所以也称为函数作用域。</code></pre></blockquote><h3 id="9-4-jS没有块级作用域"><a href="#9-4-jS没有块级作用域" class="headerlink" title="9.4 jS没有块级作用域"></a>9.4 jS没有块级作用域</h3><ul><li><p>块作用域由 { } 包括。</p></li><li><p>在其他编程语言中（如 java、c#等），在 if 语句、循环语句中创建的变量，仅仅只能在本 if 语句、本循环语句中使用，如下面的Java代码：    </p><p>java有块级作用域：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">  system.out.print(num);  <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br><span class="line">system.out.print(num);    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><pre><code>    以上java代码会报错，是因为代码中 &#123; &#125; 即一块作用域，其中声明的变量 num，在 “&#123; &#125;” 之外不能使用；而与之类似的JavaScript代码，则不会报错。</code></pre><p><strong>js中没有块级作用域（在ES6之前）</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>); <span class="comment">//123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">123</span>);   <span class="comment">//123</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="10-变量的作用域"><a href="#10-变量的作用域" class="headerlink" title="10  - 变量的作用域"></a>10  - 变量的作用域</h2><blockquote><p>在JavaScript中，根据作用域的不同，变量可以分为两种：</p></blockquote><ul><li>全局变量</li><li>局部变量</li></ul><p>10.1 全局变量</p><blockquote><p>在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。</p></blockquote><ul><li>全局变量在代码的任何位置都可以使用</li><li>在全局作用域下 var 声明的变量 是全局变量</li><li>特殊情况下，在函数内不使用 var 声明的变量也是全局变量（不建议使用）</li></ul><p>10.2 局部变量</p><blockquote><p>在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量）</p></blockquote><ul><li>局部变量只能在该函数内部使用</li><li>在函数内部 var 声明的变量是局部变量</li><li>函数的形参实际上就是局部变量</li></ul><p>10.3 全局变量和局部变量的区别</p><ul><li>全局变量：在任何一个地方都可以使用，只有在浏览器关闭时才会被销毁，因此比较占内存</li><li>局部变量：只在函数内部使用，当其所在的代码块被执行时，会被初始化；当代码块运行结束后，就会被销毁，因此更节省内存空间</li></ul><h2 id="11-作用域链"><a href="#11-作用域链" class="headerlink" title="11 - 作用域链"></a>11 - 作用域链</h2><pre><code>    只要是代码都一个作用域中，写在函数内部的局部作用域，未写在任何函数内部即在全局作用域中；如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域；根据在**[内部函数可以访问外部函数变量]**的这种机制，用链式查找决定哪些数据能被内部函数访问，就称作作用域链。</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">案例分析<span class="number">1</span>：</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">f2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>( num );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">f2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">456</span>;</span><br><span class="line"><span class="title function_">f1</span>();</span><br></pre></td></tr></table></figure><p><img src="D:\桌面\学习\前端\笔记\images\11_1.png"></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">作用域链：采取就近原则的方式来查找变量最终的值</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="string">&#x27;22&#x27;</span>;</span><br><span class="line">    <span class="title function_">fn2</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">        <span class="title function_">fn3</span>();</span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">fn3</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//a的值 ?</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(b); <span class="comment">//b的值 ?</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>();</span><br></pre></td></tr></table></figure><p><img src="D:\桌面\学习\前端\笔记\images\11_2.png"></p><h2 id="12-预解析"><a href="#12-预解析" class="headerlink" title="12 - 预解析"></a>12 - 预解析</h2><p>12.1 预解析的相关概念</p><p>JavaScript 代码是由浏览器中的 JavaScript 解析器来执行的。</p><p>JavaScript 解析器在运行 JavaScript 代码的时候分为两步：</p><pre><code>预解析和代码执行。</code></pre><ul><li><p>预解析：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义，预解析也叫做变量、函数提升。</p></li><li><p>代码执行： 从上到下执行JS语句。</p><p>注意：<strong>预解析会把变量和函数的声明在代码执行之前执行完成。</strong></p></li></ul><p>12.2 变量预解析</p><pre><code>**变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升。**</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num);  <span class="comment">// 结果是多少？</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;      <span class="comment">// ？</span></span><br></pre></td></tr></table></figure><p>结果：undefined<br>注意：<strong>变量提升只提升声明，不提升赋值</strong></p><p>12.3 函数预解析</p><pre><code> **函数的声明会被提升到当前作用域的最上面，但是不会调用函数。**</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;打印&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：控制台打印字符串 — ”打印“ </p><p>注意：函数声明代表函数整体，所以函数提升后，函数名代表整个函数，但是函数并没有被调用！    </p><p>12.4 函数表达式声明函数问题</p><p>函数表达式创建函数，会执行变量提升</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="keyword">var</span>  fn = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;想不到吧&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：报错提示 ”fn is not a function”</p><p>解释：该段代码执行之前，会做变量声明提升，fn在提升之后的值是undefined；而fn调用是在fn被赋值为函数体之前，此时fn的值是undefined，所以无法正确调用</p><h2 id="13-对象"><a href="#13-对象" class="headerlink" title="13 - 对象"></a>13 - 对象</h2><h3 id="13-1-对象的相关概念"><a href="#13-1-对象的相关概念" class="headerlink" title="13.1 对象的相关概念"></a>13.1 对象的相关概念</h3><ul><li><p>什么是对象？</p><pre><code>    在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。        对象是由属性和方法组成的。</code></pre><ul><li><p>属性：事物的特征，在对象中用属性来表示（常用名词）</p></li><li><p>方法：事物的行为，在对象中用方法来表示（常用动词）</p><p><img src="D:\桌面\学习\前端\笔记\images\13_1.png"></p></li></ul></li><li><p>为什么需要对象？</p><pre><code>    保存一个值时，可以使用变量，保存多个值（一组值）时，可以使用数组。        如果要保存一个人的完整信息呢？        例如，将“张三疯”的个人的信息保存在数组中的方式为：</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [‘张三疯’, ‘男&#x27;, 128,154];</span><br></pre></td></tr></table></figure><pre><code>    上述例子中用数组保存数据的缺点是：数据只能通过索引值访问，开发者需要清晰的清除所有的数据的排行才能准确地获取数据，而当数据量庞大时，不可能做到记忆所有数据的索引值。      为了让更好地存储一组数据，对象应运而生：对象中为每项数据设置了属性名称，可以访问数据更语义化，数据结构清晰，表意明显，方便开发者使用。</code></pre><p>使用对象记录上组数据为：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三疯&quot;</span>,</span><br><span class="line">    <span class="string">&quot;sex&quot;</span>:<span class="string">&quot;男&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="number">128</span>,</span><br><span class="line">    <span class="string">&quot;height&quot;</span>:<span class="number">154</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JS中的对象表达结构更清晰，更强大。</p></li></ul><h3 id="13-2-创建对象的三种方式"><a href="#13-2-创建对象的三种方式" class="headerlink" title="13.2 创建对象的三种方式"></a>13.2 创建对象的三种方式</h3><h4 id="利用字面量创建对象"><a href="#利用字面量创建对象" class="headerlink" title="利用字面量创建对象"></a>利用字面量创建对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">花括号 &#123; &#125; 里面包含了表达这个具体事物（对象）的属性和方法；&#123; &#125; 里面采取键值对的形式表示 </span><br></pre></td></tr></table></figure><ul><li><p>键：相当于属性名</p></li><li><p>值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）</p><p>代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> star = &#123;</span><br><span class="line">    name : <span class="string">&#x27;pink&#x27;</span>,</span><br><span class="line">    age : <span class="number">18</span>,</span><br><span class="line">    sex : <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">    sayHi : <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&#x27;大家好啊~&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码中 star即是创建的对象。</p></li><li><p>对象的使用</p><ul><li><p>对象的属性</p><ul><li>对象中存储<strong>具体数据</strong>的 “键值对”中的 “键”称为对象的属性，即对象中存储具体数据的项</li></ul></li><li><p>对象的方法</p><ul><li>对象中存储<strong>函数</strong>的 “键值对”中的 “键”称为对象的方法，即对象中存储函数的项</li></ul></li><li><p>访问对象的属性</p><ul><li><p>对象里面的属性调用 : <strong>对象.属性名</strong> ，这个小点 . 就理解为“ 的 ”  </p></li><li><p>对象里面属性的另一种调用方式 : **对象[‘属性名’]**，注意方括号里面的属性必须加引号      </p><p>示例代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(star.<span class="property">name</span>)     <span class="comment">// 调用名字属性</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(star[<span class="string">&#x27;name&#x27;</span>])  <span class="comment">// 调用名字属性</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>调用对象的方法</p><ul><li><p>对象里面的方法调用：<strong>对象.方法名()</strong> ，注意这个方法名字后面一定加括号 </p><p>示例代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">star.<span class="title function_">sayHi</span>(); <span class="comment">// 调用 sayHi 方法,注意一定要带后面的括号</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>变量、属性、函数、方法总结</p><pre><code>    属性是对象的一部分，而变量不是对象的一部分，变量是单独存储数据的容器</code></pre><ul><li><p>变量：单独声明赋值，单独存在</p></li><li><p>属性：对象里面的变量称为属性，不需要声明</p><pre><code>方法是对象的一部分，函数是单独封装操作的容器</code></pre></li><li><p>函数：单独存在的，通过“函数名()”的方式就可以调用</p></li><li><p>方法：对象里面的函数称为方法，方法不需要声明，使用“对象.方法名()”的方式就可以调用</p></li></ul></li></ul></li></ul><h4 id="利用-new-Object-创建对象"><a href="#利用-new-Object-创建对象" class="headerlink" title="利用 new Object 创建对象"></a>利用 new Object 创建对象</h4><ul><li><p>创建空对象</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> andy = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure><p>通过内置构造函数Object创建对象，此时andy变量已经保存了创建出来的空对象</p></li><li><p>给空对象添加属性和方法</p><ul><li><p>通过对象操作属性和方法的方式，来为对象增加属性和方法</p><p>示例代码如下：</p></li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">andy.<span class="property">name</span> = <span class="string">&#x27;pink&#x27;</span>;</span><br><span class="line">andy.<span class="property">age</span> = <span class="number">18</span>;</span><br><span class="line">andy.<span class="property">sex</span> = <span class="string">&#x27;男&#x27;</span>;</span><br><span class="line">andy.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;大家好啊~&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>Object() ：第一个字母大写   </li><li>new Object() ：需要 new 关键字</li><li>使用的格式：对象.属性 =  值;     </li></ul></li></ul><h4 id="利用构造函数创建对象"><a href="#利用构造函数创建对象" class="headerlink" title="利用构造函数创建对象"></a>利用构造函数创建对象</h4><ul><li><p>构造函数</p><ul><li><p>构造函数：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p></li><li><p>构造函数的封装格式：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> 构造函数名(形参<span class="number">1</span>,形参<span class="number">2</span>,形参<span class="number">3</span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.属性名<span class="number">1</span> = 参数<span class="number">1</span>;</span><br><span class="line">     <span class="variable language_">this</span>.属性名<span class="number">2</span> = 参数<span class="number">2</span>;</span><br><span class="line">     <span class="variable language_">this</span>.属性名<span class="number">3</span> = 参数<span class="number">3</span>;</span><br><span class="line">     <span class="variable language_">this</span>.方法名 = 函数体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数的调用格式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = new 构造函数名(实参1，实参2，实参3)</span><br></pre></td></tr></table></figure><p>以上代码中，obj即接收到构造函数创建出来的对象。</p></li><li><p>注意事项</p><ol><li>构造函数约定<strong>首字母大写</strong>。</li><li>函数内的属性和方法前面需要添加 <strong>this</strong> ，表示当前对象的属性和方法。</li><li>构造函数中<strong>不需要 return 返回结果</strong>。</li><li>当我们创建对象的时候，<strong>必须用 new 来调用构造函数</strong>。</li></ol></li><li><p>其他</p><p>构造函数，如 Stars()，抽象了对象的公共部分，封装到了函数里面，它泛指某一大类（class）<br>创建对象，如 new Stars()，特指某一个，通过 new 关键字创建对象的过程我们也称为对象实例化</p></li></ul></li><li><p>new关键字的作用</p><ol><li>在构造函数代码开始执行之前，创建一个空对象；</li><li>修改this的指向，把this指向创建出来的空对象；</li><li>执行函数的代码</li><li>在函数完成之后，返回this—即创建出来的对象</li></ol><h3 id="13-3-遍历对象"><a href="#13-3-遍历对象" class="headerlink" title="13.3 遍历对象"></a>13.3 遍历对象</h3><pre><code>    **for...in 语句用于对数组或者对象的属性进行循环操作。**      其语法如下：</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (变量 <span class="keyword">in</span> 对象名字) &#123;</span><br><span class="line">    <span class="comment">// 在此执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>    语法中的变量是自定义的，它需要符合命名规范，通常我们会将这个变量写为 k 或者 key。</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k);      <span class="comment">//  k 变量输出 得到属性名</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[k]); <span class="comment">//  obj[k] 得到属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="14-内置对象"><a href="#14-内置对象" class="headerlink" title="14 - 内置对象"></a>14 - 内置对象</h2><h3 id="14-1-内置对象"><a href="#14-1-内置对象" class="headerlink" title="14.1 内置对象"></a>14.1 内置对象</h3><pre><code>     JavaScript 中的对象分为3种：**自定义对象 、内置对象、 浏览器对象**    前面两种对象是JS 基础 内容，属于 ECMAScript；  第三个浏览器对象属于 JS 独有的， JS API 讲解内置对象就是指 JS 语言自带的一些对象，这些对象供开发者使用，并提供了一些常用的或是**最基本而必要的功能**（属性和方法），内置对象最大的优点就是帮助我们快速开发     JavaScript 提供了多个内置对象：Math、 Date 、Array、String等    </code></pre><h3 id="14-2-查文档"><a href="#14-2-查文档" class="headerlink" title="14.2 查文档"></a>14.2 查文档</h3><pre><code>    查找文档：学习一个内置对象的使用，只要学会其常用成员的使用即可，我们可以通过查文档学习，可以通过MDN/W3C来查询。    Mozilla 开发者网络（MDN）提供了有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。    MDN:https://developer.mozilla.org/zh-CN/</code></pre><h3 id="14-3-Math对象"><a href="#14-3-Math对象" class="headerlink" title="14.3 Math对象"></a>14.3 Math对象</h3><pre><code>    Math 对象不是构造函数，它具有数学常数和函数的属性和方法。跟数学相关的运算（求绝对值，取整、最大值等）可以使用 Math 中的成员。</code></pre><table><thead><tr><th>属性、方法名</th><th>功能</th></tr></thead><tbody><tr><td>Math.PI</td><td>圆周率</td></tr><tr><td>Math.floor()</td><td>向下取整</td></tr><tr><td>Math.ceil()</td><td>向上取整</td></tr><tr><td>Math.round()</td><td>四舍五入版 就近取整   注意 -3.5   结果是  -3</td></tr><tr><td>Math.abs()</td><td>绝对值</td></tr><tr><td>Math.max()/Math.min()</td><td>求最大和最小值</td></tr><tr><td>Math.random()</td><td>获取范围在[0,1)内的随机值</td></tr></tbody></table><pre><code>注意：上面的方法使用时必须带括号**获取指定范围内的随机整数**：</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getRandom</span>(<span class="params">min, max</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * (max - min + <span class="number">1</span>)) + min; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="14-4-日期对象"><a href="#14-4-日期对象" class="headerlink" title="14.4 日期对象"></a>14.4 日期对象</h3><pre><code>     Date 对象和 Math 对象不一样，Date是一个构造函数，所以使用时需要实例化后才能使用其中具体方法和属性。Date 实例用来处理日期和时间</code></pre><ul><li><p>使用Date实例化日期对象</p><ul><li>获取当前时间必须实例化：</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure><ul><li>获取指定时间的日期对象</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> future = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2019/5/1&#x27;</span>);</span><br></pre></td></tr></table></figure><p>注意：如果创建实例时并未传入参数，则得到的日期对象是当前时间对应的日期对象</p></li><li><p>使用Date实例的方法和属性    </p></li><li><p>通过Date实例获取总毫米数</p><ul><li><p>总毫秒数的含义</p><pre><code>基于1970年1月1日（世界标准时间）起的毫秒数</code></pre></li><li><p>获取总毫秒数</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化Date对象</span></span><br><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">// 1. 用于获取对象的原始值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">valueOf</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date.<span class="title function_">getTime</span>())</span><br><span class="line"><span class="comment">// 2. 简单写可以这么做</span></span><br><span class="line"><span class="keyword">var</span> now = + <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">// 3. HTML5中提供的方法，有兼容性问题</span></span><br><span class="line"><span class="keyword">var</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="14-5-数组对象"><a href="#14-5-数组对象" class="headerlink" title="14.5 数组对象"></a>14.5 数组对象</h3><h4 id="创建数组的两种方式"><a href="#创建数组的两种方式" class="headerlink" title="创建数组的两种方式"></a>创建数组的两种方式</h4><ul><li><p>字面量方式</p><ul><li><p>示例代码如下：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="string">&quot;test&quot;</span>,<span class="literal">true</span>];</span><br></pre></td></tr></table></figure></li></ul></li><li><p>new Array()</p><ul><li><p>示例代码如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = new Array();</span><br></pre></td></tr></table></figure><pre><code>注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数    参数传递规则如下：</code></pre><ul><li>如果只传入一个参数，则参数规定了<strong>数组的长度</strong></li><li>如果传入了多个参数，则参数称为数组的元素</li></ul></li></ul></li></ul><h4 id="检测是否为数组"><a href="#检测是否为数组" class="headerlink" title="检测是否为数组"></a>检测是否为数组</h4><ul><li><p>instanceof 运算符</p><ul><li><p>instanceof 可以判断一个对象是否是某个构造函数的实例</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">23</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Array.isArray()</p><ul><li><p>Array.isArray()用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">23</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr));   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj));   <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="添加删除数组元素的方法"><a href="#添加删除数组元素的方法" class="headerlink" title="添加删除数组元素的方法"></a>添加删除数组元素的方法</h4><ul><li><p>数组中有进行增加、删除元素的方法，部分方法如下表</p><table><thead><tr><th>方法名</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td>push(参数1…)</td><td>末尾添加一个或多个元素，数组长度增加</td><td>返回新的长度</td></tr><tr><td>pop()</td><td>删除数组最后一个元素，数组长度减1</td><td>返回它删除的元素的值</td></tr><tr><td>unshift(参数1…)</td><td>向数组的开头添加一个或更多元素，数组长度增加</td><td>返回新的长度</td></tr><tr><td>shift()</td><td>删除数组的第一个元素，数组长度减1</td><td>返回它删除的元素的值</td></tr></tbody></table><p>注意：push、unshift为增加元素方法；pop、shift为删除元素的方法</p></li></ul><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><ul><li><p>数组中有对数组本身排序的方法，部分方法如下表</p><table><thead><tr><th>方法名</th><th>说明</th><th>是否修改原数组</th></tr></thead><tbody><tr><td>reverse()</td><td>颠倒数组中元素的顺序，无参数</td><td>该方法会改变原来的数组 返回新数组</td></tr><tr><td>sorta()</td><td>对数组的元素进行排序</td><td>该方法会改变原来的数组 返回新数组</td></tr></tbody></table><p>注意：sort方法需要传入参数来设置升序、降序排序</p><ul><li>如果传入“function(a,b){ return a-b;}”，则为升序</li><li>如果传入“function(a,b){ return b-a;}”，则为降序</li></ul></li></ul><h4 id="数组索引方法"><a href="#数组索引方法" class="headerlink" title="数组索引方法"></a>数组索引方法</h4><ul><li><p>数组中有获取数组指定元素索引值的方法，部分方法如下表</p><table><thead><tr><th>方法名</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td>indexOf()</td><td>数组中查找给定元素的<strong>第一个</strong>索引</td><td>如果存在返回索引号 如果不存在，则返回-1</td></tr><tr><td>lastIndexOf()</td><td>在数组中的<strong>最后一个</strong>的索引</td><td>如果存在返回索引号 如果不存在，则返回-1</td></tr></tbody></table></li></ul><h4 id="数组转换为字符串"><a href="#数组转换为字符串" class="headerlink" title="数组转换为字符串"></a>数组转换为字符串</h4><ul><li><p>数组中有把数组转化为字符串的方法，部分方法如下表</p><table><thead><tr><th>方法名</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td>toString()</td><td>把数组转换成字符串，逗号分隔每一项</td><td>返回一个字符串</td></tr><tr><td>join(‘分隔符’)</td><td>方法用于把数组中所有元素转换位一个字符串</td><td>返回一个字符串</td></tr></tbody></table><p>注意：join方法如果不传入参数，则按照 “ , ”拼接元素</p></li></ul><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li><p>数组中其他操作方法</p><table><thead><tr><th>方法名</th><th>说明</th><th>返回值</th></tr></thead><tbody><tr><td>concat()</td><td>连接两个或多个数值 创建新数组 不影响原数组</td><td>返回一个新数组</td></tr><tr><td>slice()</td><td>数组截取slice(begin,end)</td><td>返回被截取项目的新数组</td></tr><tr><td>splice()</td><td>数组删除splice(第几个开始，要删除个数)</td><td>返回被删除项目的新数组 影响原数组</td></tr></tbody></table></li></ul><h3 id="14-6-字符串对象"><a href="#14-6-字符串对象" class="headerlink" title="14.6 字符串对象"></a>14.6 字符串对象</h3><h4 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h4><pre><code>    为了方便操作基本数据类型，JavaScript 还提供了三个特殊的引用类型：String、Number和 Boolean。    基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面代码有什么问题？</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;andy&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">length</span>);</span><br></pre></td></tr></table></figure><pre><code>    按道理基本数据类型是没有属性和方法的，而对象才有属性和方法，但上面代码却可以执行，这是因为    js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ：</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 生成临时变量，把简单类型包装为复杂数据类型</span></span><br><span class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&#x27;andy&#x27;</span>);</span><br><span class="line"><span class="comment">// 2. 赋值给我们声明的字符变量</span></span><br><span class="line">str = temp;</span><br><span class="line"><span class="comment">// 3. 销毁临时变量</span></span><br><span class="line">temp = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><h4 id="字符串的不可变"><a href="#字符串的不可变" class="headerlink" title="字符串的不可变"></a>字符串的不可变</h4><pre><code>    指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。    当重新给字符串变量赋值的时候，变量之前保存的字符串不会被修改，依然在内存中重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变。    由于字符串的不可变，在**大量拼接字符串**的时候会有效率问题</code></pre><h4 id="根据字符返回位置"><a href="#根据字符返回位置" class="headerlink" title="根据字符返回位置"></a>根据字符返回位置</h4><pre><code>    字符串通过基本包装类型可以调用部分方法来操作字符串，以下是返回指定字符的位置的方法：</code></pre><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>index(‘要查找的字符’，开始的位置)</td><td>返回指定内容在元素字符串中的位置，如果找不到返回-1</td></tr><tr><td>lastIndexOf()</td><td>从后往前找，只找第一个匹配的</td></tr></tbody></table><pre><code>    案例：查找字符串&quot;abcoefoxyozzopp&quot;中所有o出现的位置以及次数</code></pre><ol><li>先查找第一个o出现的位置</li><li>然后 只要indexOf 返回的结果不是 -1 就继续往后查找</li><li>因为indexOf 只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找     </li></ol><h4 id="根据位置返回字符"><a href="#根据位置返回字符" class="headerlink" title="根据位置返回字符"></a>根据位置返回字符</h4><pre><code>    字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符：</code></pre><table><thead><tr><th>方法名</th><th>说明</th><th>使用</th></tr></thead><tbody><tr><td>charAt(index)</td><td>返回指定位置的字符</td><td>str.charAt(1)</td></tr><tr><td>charCodeAt(index)</td><td>获取指定位置处字符的ASCII码</td><td>str.charCodeAt(1)</td></tr><tr><td>str[index]</td><td>获取指定位置处的字符</td><td>HTML5,IE8+支持和charAt()等效</td></tr></tbody></table><pre><code>    在上述方法中，charCodeAt方法返回的是指定位置上字符对应的ASCII码，ASCII码对照表如下：</code></pre><p><img src="D:\桌面\学习\前端\笔记\images\14_6.png"></p><pre><code>    案例：判断一个字符串 &#39;abcoefoxyozzopp&#39; 中出现次数最多的字符，并统计其次数</code></pre><ol><li><p>核心算法：利用 charAt(） 遍历这个字符串</p></li><li><p>把每个字符都存储给对象， 如果对象没有该属性，就为1，如果存在了就 +1</p></li><li><p>遍历对象，得到最大值和该字符     </p><pre><code>注意：在遍历的过程中，把字符串中的每个字符作为对象的属性存储在对象中，对应的属性值是该字符出现的次数</code></pre></li></ol><h4 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h4><pre><code>    字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法：</code></pre><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>concat(str1,str2,str3…)</td><td>concat()方法用于连接两个或多个字符串。拼接字符串，等效于+</td></tr><tr><td>substr(start,length)</td><td>从start位置开始(索引号)获取字符，length 是获取个数</td></tr><tr><td>slice(start,end)</td><td>从start位置开始(索引号)，截取到end位置</td></tr><tr><td>sunbstring(start,end)</td><td>从start位置开始(索引号)，截取到end位置，与slice基本相同，但是不接受负值</td></tr></tbody></table><h4 id="replace-方法"><a href="#replace-方法" class="headerlink" title="replace()方法"></a>replace()方法</h4><pre><code>    replace() 方法用于在字符串中用一些字符替换另一些字符，其使用格式如下：  </code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符串.replace(被替换的字符串， 要替换为的字符串)；</span><br></pre></td></tr></table></figure><h4 id="split-方法"><a href="#split-方法" class="headerlink" title="split()方法"></a>split()方法</h4><pre><code>    split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。    其使用格式如下：</code></pre><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字符串.split(&quot;分割字符&quot;)</span><br></pre></td></tr></table></figure><h2 id="15-简单数据类型和复杂数据类型"><a href="#15-简单数据类型和复杂数据类型" class="headerlink" title="15 - 简单数据类型和复杂数据类型"></a>15 - 简单数据类型和复杂数据类型</h2><h3 id="15-1-简单数据类型"><a href="#15-1-简单数据类型" class="headerlink" title="15.1 简单数据类型"></a>15.1 简单数据类型</h3><pre><code>    **简单类型**（**基本数据类型**、**值类型**）：在存储时变量中存储的是值本身，包括string ，number，boolean，undefined，null</code></pre><h3 id="15-2-复杂数据类型"><a href="#15-2-复杂数据类型" class="headerlink" title="15.2 复杂数据类型"></a>15.2 复杂数据类型</h3><pre><code>    **复杂数据类型（引用类型）**：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等；</code></pre><h3 id="15-3-堆栈"><a href="#15-3-堆栈" class="headerlink" title="15.3 堆栈"></a>15.3 堆栈</h3><ul><li>堆栈空间分配区别：</li></ul><p>　　1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈；</p><p>简单数据类型存放到栈里面</p><p>　　2、堆（操作系统）：存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。</p><p><img src="D:\桌面\学习\前端\笔记\images\15_1.png"></p><ul><li><p>简单数据类型的存储方式</p><pre><code>    值类型变量的数据直接存放在变量（栈空间）中</code></pre></li></ul><p><img src="D:\桌面\学习\前端\笔记\images\15_2.png"></p><ul><li><p>复杂数据类型的存储方式</p><pre><code>    引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中</code></pre></li></ul><p><img src="D:\桌面\学习\前端\笔记\images\15_3.png"></p><h3 id="15-4-简单类型传参"><a href="#15-4-简单类型传参" class="headerlink" title="15.4 简单类型传参"></a>15.4 简单类型传参</h3><pre><code>    函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</code></pre><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);<span class="comment">//11 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="title function_">fn</span>(x);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x)；<span class="comment">//10</span></span><br></pre></td></tr></table></figure><h3 id="15-5-复杂数据类型传参"><a href="#15-5-复杂数据类型传参" class="headerlink" title="15.5 复杂数据类型传参"></a>15.5 复杂数据类型传参</h3><pre><code>    函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</code></pre><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f1</span>(<span class="params">x</span>) &#123; <span class="comment">// x = p</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">name</span>); <span class="comment">//刘德华   </span></span><br><span class="line">    x.<span class="property">name</span> = <span class="string">&quot;张学友&quot;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x.<span class="property">name</span>); <span class="comment">//张学友    </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;刘德华&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>);    <span class="comment">//刘德华</span></span><br><span class="line"><span class="title function_">f1</span>(p);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p.<span class="property">name</span>);    <span class="comment">//张学友  </span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;一、JavaScript语法&quot;&gt;&lt;a href=&quot;#一、JavaScript语法&quot; class=&quot;headerlink&quot; title=&quot;一、JavaScript语法&quot;&gt;&lt;/a&gt;一、JavaScript语法&lt;/h1&gt;&lt;h2 id=&quot;1-初始JavaScri</summary>
      
    
    
    
    
    <category term="js" scheme="http://example.com/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>我的个人简介</title>
    <link href="http://example.com/post/4a17b156.html"/>
    <id>http://example.com/post/4a17b156.html</id>
    <published>2022-09-28T16:32:29.105Z</published>
    <updated>2022-10-02T15:06:18.905Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><hr><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">壁纸</div>  <p>收藏的一些壁纸</p>  <a href='/Gallery/wallpaper'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">漫威</div>  <p>关于漫威的图片</p>  <a href='/Gallery/marvel'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">OH MY GIRL</div>  <p>关于OH MY GIRL的图片</p>  <a href='/Gallery/ohmygirl'></a>  </figcaption>  </figure>  </div><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
    <category term="个人介绍" scheme="http://example.com/tags/%E4%B8%AA%E4%BA%BA%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
</feed>
